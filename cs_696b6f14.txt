---------------------------------------------
// File core/input.go
package core

import (
	"catexplore/export"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"time"
)

func CaptureInput(key string) string {
	// Aquí manejas las teclas que recibes
	switch key {
	case "j", "Down":
		return "down"
	case "k", "Up":
		return "up"
	default:
		return ""
	}
}

func HandleKeyPress(key string, position, itemCount int, selected map[string]bool, items []string, s *Selector) int {
	switch key {
	case "q":
		// Restaurar la terminal y salir
		fmt.Print("\033[?1049l")
		os.Exit(0)
	case "down", "j":
		if s.ActivePanel == 1 {
			position++
			if position >= itemCount {
				position = 0
			}
		} else if s.ActivePanel == 2 {
			s.FilePosition++
			if s.FilePosition >= len(s.Files) {
				s.FilePosition = 0
			}
		}
	case "up", "k":
		if s.ActivePanel == 1 {
			position--
			if position < 0 {
				position = itemCount - 1
			}
		} else if s.ActivePanel == 2 {
			s.FilePosition--
			if s.FilePosition < 0 {
				s.FilePosition = len(s.Files) - 1
			}
		}
	case "i":
		// Toggle del modo include
		s.IncludeMode = !s.IncludeMode
	case "o":
		// Exportar y abrir en aplicación externa
		selectedPaths := getSelectedPaths(s.Selection)
		excludedPaths := getExcludedPaths(s)
		outputFile := export.GenerateTextFile(
			selectedPaths,
			excludedPaths,
			s.IncludeMode,
			GetRootDirectory(),
			s.Directory,
		)
		if outputFile != "" {
			// Abrir el archivo sin salir del modo alternativo
			err := OpenTextFile(outputFile)

			// Mostrar mensaje de éxito o error
			if err == nil {
				s.StatusMessage = "Archivo abierto: " + filepath.Base(outputFile)
			} else {
				s.StatusMessage = "Error al abrir el archivo"
			}
			s.StatusTime = time.Now().Unix()
		}
	case "c":
		// Exportar, copiar al portapapeles y eliminar archivo
		selectedPaths := getSelectedPaths(s.Selection)
		excludedPaths := getExcludedPaths(s)
		outputFile := export.GenerateTextFile(
			selectedPaths,
			excludedPaths,
			s.IncludeMode,
			GetRootDirectory(),
			s.Directory,
		)

		if outputFile != "" {
			// Leer el contenido del archivo
			content, err := os.ReadFile(outputFile)
			if err == nil {
				// Copiar al portapapeles según el sistema operativo
				success := copyToClipboard(string(content))

				// Eliminar el archivo temporal
				os.Remove(outputFile)

				// Contar archivos seleccionados para el mensaje de estado
				selectedFiles := countSelectedFiles(s)

				// Preparar mensaje y guardar estado
				msg := ""
				if success {
					msg = fmt.Sprintf("%d archivos copiados al portapapeles", selectedFiles)
				} else {
					msg = "Error al copiar al portapapeles"
				}
				s.StatusMessage = msg
				s.StatusTime = time.Now().Unix()
			}
		}
	case "tab":
		// Guardar el panel anterior
		previousPanel := s.ActivePanel

		// Cambiar solo entre los paneles de directorios y archivos (1 y 2)
		if s.ActivePanel == 1 {
			s.ActivePanel = 2
		} else {
			s.ActivePanel = 1
		}

		// Solo actualizar los archivos cuando cambiamos del panel de directorios al panel de archivos
		if previousPanel == 1 && s.ActivePanel == 2 {
			// Si venimos del panel de directorios, actualizar los archivos del directorio seleccionado
			if position >= 0 && position < len(items) {
				item := items[position]
				var selectedDir string
				if item == ".." {
					selectedDir = filepath.Dir(s.Directory)
				} else if item == "." {
					selectedDir = s.Directory
				} else {
					selectedDir = filepath.Join(s.Directory, item)
				}

				// Verificar si el directorio existe y es accesible
				if info, err := os.Stat(selectedDir); err == nil && info.IsDir() {
					// Actualizar la lista de archivos para el directorio seleccionado
					files, err := os.ReadDir(selectedDir)
					if err == nil {
						var fileList []string
						for _, file := range files {
							if !file.IsDir() { // Solo archivos
								fileList = append(fileList, file.Name())
							}
						}
						s.Files = fileList // Actualizamos los archivos
						s.FilePosition = 0 // Resetear la posición en el panel de archivos
					} else {
						s.Files = []string{} // Si hay error, limpiamos la lista de archivos
					}
				}
			}
		} else if s.ActivePanel == 2 && len(s.Files) > 0 {
			// Si ya estamos en el panel de archivos, solo resetear la posición
			s.FilePosition = 0
		}
	case "enter", "l":
		if s.ActivePanel == 1 && position >= 0 && position < len(items) {
			item := items[position]
			var newDir string
			if item == ".." {
				newDir = filepath.Dir(s.Directory)
			} else if item == "." {
				newDir = s.Directory
			} else {
				newDir = filepath.Join(s.Directory, item)
			}

			// Verificar si el directorio existe y es accesible
			if info, err := os.Stat(newDir); err == nil && info.IsDir() {
				// Guardar el estado actual en el historial antes de cambiar
				s.History = append(s.History, NavigationHistory{
					Directory: s.Directory,
					Position:  position,
				})

				s.Directory = newDir
				s.Filtered = PrepareDirItems(newDir)

				// Buscar la posición de "." en la nueva lista
				for i, item := range s.Filtered {
					if item == "." {
						position = i
						s.Position = i
						break
					}
				}

				items = s.Filtered // Actualizar los items con los nuevos
			}
		}
	case "esc", "h":
		// Navegar hacia atrás si no estamos en el directorio raíz de la aplicación
		rootDir := GetRootDirectory()
		if s.Directory != rootDir && len(s.History) > 0 {
			// Obtener el último estado del historial
			lastState := s.History[len(s.History)-1]

			// Verificar si el directorio del historial existe y es accesible
			if info, err := os.Stat(lastState.Directory); err == nil && info.IsDir() {
				s.Directory = lastState.Directory
				s.Filtered = PrepareDirItems(lastState.Directory)
				position = lastState.Position
				s.Position = lastState.Position
				items = s.Filtered

				// Eliminar el último estado del historial
				s.History = s.History[:len(s.History)-1]
			}
		}
	case "s":
		if s.ActivePanel == 1 {
			// Toggle de selección del directorio actual
			if position >= 0 && position < len(items) {
				item := items[position]
				if item != ".." {
					// Obtener el selector actual
					selector := GetCurrentSelector()

					// Determinar el estado actual de selección
					isSelected := selector.IsSelected(item)

					// Procesar el directorio actual
					dirPath := filepath.Join(s.Directory, item)
					processDirectoryRecursive(selector, dirPath, item, !isSelected)

					// Actualizar la lista de archivos si es necesario
					if !isSelected {
						// Si estamos seleccionando, actualizar la lista de archivos
						UpdateFileList(selector, s.Directory, item)
					} else {
						// Si estamos deseleccionando, limpiar la lista de archivos
						s.Files = []string{}
						s.FilePosition = 0
					}
				}
			}
		} else if s.ActivePanel == 2 && s.FilePosition >= 0 && s.FilePosition < len(s.Files) {
			// Obtener el nombre del archivo seleccionado
			selectedFile := s.Files[s.FilePosition]
			// Cambiar el estado de selección
			fileKey := s.GetFileSelectionKey(selectedFile)
			s.Selection[fileKey] = !s.Selection[fileKey]
		}
	case "a":
		if s.ActivePanel == 1 {
			// Verificar si todos los directorios están seleccionados (excluyendo '..' y '.')
			allSelected := true
			for _, item := range items {
				if item != ".." && item != "." && !s.IsSelected(item) {
					allSelected = false
					break
				}
			}

			// Si todos están seleccionados, deseleccionar todos (excluyendo '..' y '.')
			// Si no todos están seleccionados, seleccionar todos (excluyendo '..' y '.')
			for _, item := range items {
				if item != ".." && item != "." {
					// Procesar el directorio y sus subdirectorios si el modo include está activo
					dirPath := filepath.Join(s.Directory, item)
					processDirectoryRecursive(s, dirPath, item, !allSelected)
				}
			}
		} else if s.ActivePanel == 2 {
			// Verificar si todos los archivos están seleccionados
			allSelected := true
			for _, file := range s.Files {
				fileKey := s.GetFileSelectionKey(file)
				if !s.Selection[fileKey] {
					allSelected = false
					break
				}
			}

			// Si todos están seleccionados, deseleccionar todos
			// Si no todos están seleccionados, seleccionar todos
			for _, file := range s.Files {
				fileKey := s.GetFileSelectionKey(file)
				s.Selection[fileKey] = !allSelected
			}
		}
	}

	// Actualizar la posición en el selector
	s.Position = position

	// Actualizar los archivos cuando se navega
	s.UpdateFilesForCurrentDirectory()

	return position
}

// UpdateFileList actualiza la lista de archivos para un directorio
func UpdateFileList(selector *Selector, currentDir string, item string) {
	dirPath := filepath.Join(currentDir, item)
	files, err := os.ReadDir(dirPath)
	if err == nil {
		var fileList []string
		for _, file := range files {
			if !file.IsDir() { // Solo archivos
				fileList = append(fileList, file.Name())
			}
		}
		selector.Files = fileList
	}
}

// Función para obtener una lista de rutas seleccionadas
func getSelectedPaths(selection map[string]bool) []string {
	var paths []string
	for path, selected := range selection {
		if selected {
			paths = append(paths, path)
		}
	}
	return paths
}

// Función para obtener las rutas excluidas
func getExcludedPaths(s *Selector) []string {
	// Esta implementación dependerá de cómo manejes las exclusiones en tu modelo
	// Por ahora, retorna una lista vacía
	return []string{}
}

// Contar archivos seleccionados
func countSelectedFiles(s *Selector) int {
	count := 0
	for path, selected := range s.Selection {
		if selected {
			info, err := os.Stat(path)
			if err == nil {
				if !info.IsDir() {
					count++
				} else if s.IncludeMode {
					// Contar archivos en el directorio si IncludeMode está activo
					filepath.Walk(path, func(p string, info os.FileInfo, err error) error {
						if err == nil && !info.IsDir() {
							count++
						}
						return nil
					})
				} else {
					// Contar solo archivos en el nivel superior del directorio
					files, err := os.ReadDir(path)
					if err == nil {
						for _, file := range files {
							fileInfo, err := file.Info()
							if err == nil && !fileInfo.IsDir() {
								count++
							}
						}
					}
				}
			}
		}
	}
	return count
}

// Función para copiar al portapapeles
func copyToClipboard(text string) bool {
	var cmd *exec.Cmd

	switch runtime.GOOS {
	case "darwin": // macOS
		cmd = exec.Command("pbcopy")
	case "windows":
		// En Windows, necesitarías usar otro método, como el paquete clipboard
		// Por ahora, devolvemos falso como indicación de que no se soporta
		return false
	default: // Linux y otros
		// Primero intentar con xclip
		if _, err := exec.LookPath("xclip"); err == nil {
			cmd = exec.Command("xclip", "-selection", "clipboard")
		} else if _, err := exec.LookPath("xsel"); err == nil {
			// Luego intentar con xsel
			cmd = exec.Command("xsel", "--clipboard", "--input")
		} else if _, err := exec.LookPath("wl-copy"); err == nil {
			// Luego intentar con wl-copy (Wayland)
			cmd = exec.Command("wl-copy")
		} else {
			// No se encontró ninguna utilidad de portapapeles
			return false
		}
	}

	if cmd == nil {
		return false
	}

	// Crear un pipe para pasar el texto al comando
	pipe, err := cmd.StdinPipe()
	if err != nil {
		return false
	}

	// Iniciar el comando
	if err := cmd.Start(); err != nil {
		return false
	}

	// Escribir el texto en el pipe
	_, err = pipe.Write([]byte(text))
	if err != nil {
		return false
	}

	// Cerrar el pipe
	pipe.Close()

	// Esperar a que termine el comando
	return cmd.Wait() == nil
}
// End of file core/input.go

---------------------------------------------
// File core/model.go
package core
// End of file core/model.go

---------------------------------------------
// File core/styles.go
// core/styles.go
package core

import "github.com/charmbracelet/lipgloss"

// Colors
var (
	// Directories
	Green = lipgloss.NewStyle().Foreground(lipgloss.Color("2"))
	// Panel Headers
	Cyan = lipgloss.NewStyle().Foreground(lipgloss.Color("6"))
	// Files
	White = lipgloss.NewStyle().Foreground(lipgloss.Color("7"))
	// Selected item
	// Marked items
	Marked = lipgloss.NewStyle().Foreground(lipgloss.Color("11")).Background(lipgloss.Color("0"))
	// Headers
	Header = lipgloss.NewStyle().Foreground(lipgloss.Color("6")).Background(lipgloss.Color("0"))
	// Active panel header
	ActiveHeader = lipgloss.NewStyle().Foreground(lipgloss.Color("0")).Background(lipgloss.Color("6"))
	// Directory icon
	DirectoryIcon = lipgloss.NewStyle().Foreground(lipgloss.Color("11")).Background(lipgloss.Color("0"))
	// File icon
	FileIcon = lipgloss.NewStyle().Foreground(lipgloss.Color("12")).Background(lipgloss.Color("0"))
	// Key hints
	KeyHints = lipgloss.NewStyle().Foreground(lipgloss.Color("13")).Background(lipgloss.Color("0"))
	// Key hint text
	KeyHintText = lipgloss.NewStyle().Foreground(lipgloss.Color("15")).Background(lipgloss.Color("0"))
	// Magenta text
	Magenta = lipgloss.NewStyle().Foreground(lipgloss.Color("13"))
	// Yellow text for selected files
	Yellow = lipgloss.NewStyle().Foreground(lipgloss.Color("3"))
	// Blue text for counters
	Blue = lipgloss.NewStyle().Foreground(lipgloss.Color("4"))
)

// Styles for the layout (combined into one block)
var (
	// Directory text and the directory display
	DirectoryText = lipgloss.NewStyle().Foreground(lipgloss.Color("7"))
	DirectoryDir  = lipgloss.NewStyle().Foreground(lipgloss.Color("3"))
	// Title on the right (Cat Explorer)
	HeaderTitle = lipgloss.NewStyle().Foreground(lipgloss.Color("3"))
)


var (
	Focus = lipgloss.NewStyle().
	Foreground(lipgloss.Color("0")).
	Background(lipgloss.Color("7")) // blanco
	Selected = lipgloss.NewStyle().Foreground(lipgloss.Color("212"))
)
// End of file core/styles.go

---------------------------------------------
// File core/utils.go
package core

import (
	"os"
	"os/exec"
	"runtime"
	"sort"
)

var rootDirectory string

func OpenTextFile(path string) error {
	var cmd *exec.Cmd

	switch runtime.GOOS {
	case "darwin": // macOS
		cmd = exec.Command("open", path)
	case "windows": // Windows
		cmd = exec.Command("cmd", "/c", "start", "", path)
	default: // Linux y otros
		// Intentar xdg-open (estándar para la mayoría de distribuciones Linux)
		if _, err := exec.LookPath("xdg-open"); err == nil {
			cmd = exec.Command("xdg-open", path)
		} else if _, err := exec.LookPath("gnome-open"); err == nil {
			cmd = exec.Command("gnome-open", path)
		} else if _, err := exec.LookPath("kde-open"); err == nil {
			cmd = exec.Command("kde-open", path)
		} else {
			return os.ErrNotExist
		}
	}

	return cmd.Start()
}

// GetRootDirectory devuelve el directorio desde donde se ejecuta la aplicación
func GetRootDirectory() string {
	if rootDirectory == "" {
		dir, err := os.Getwd()
		if err != nil {
			rootDirectory = "/"
		} else {
			rootDirectory = dir
		}
	}
	return rootDirectory
}

func PrepareDirItems(pwd string) []string {
	files, _ := os.ReadDir(pwd)
	var dirs []string
	for _, f := range files {
		if f.IsDir() {
			dirs = append(dirs, f.Name())
		}
	}
	sort.Strings(dirs)

	// Añadir ".." como primer item si no estamos en el directorio root
	rootDir := GetRootDirectory()
	if pwd != rootDir {
		return append([]string{"..", "."}, dirs...)
	}
	return append([]string{"."}, dirs...)
}

// Get the current directory
func GetCurrentDirectory() string {
	dir, err := os.Getwd()
	if err != nil {
		return "/" // Return root if there's an error getting the current directory
	}
	return dir
}
// End of file core/utils.go

---------------------------------------------
// File core/draw.go
package core

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/charmbracelet/lipgloss"
	"golang.org/x/term"
)

func DrawLayout(position int, items []string, currentDir string, files []string, activePanel int, filePosition int) string {
	width, height := getTerminalSize()
	dirPrefix := "Directory: "
	titleText := "Cat Explorer"
	minSpacing := 2

	available := width - len(dirPrefix) - len(titleText) - minSpacing
	narrow := len(currentDir) > available

	// 1ª línea: prefijo + espacios + título
	spaces := width - len(dirPrefix) - len(titleText)
	if spaces < minSpacing {
		spaces = minSpacing
	}
	header := fmt.Sprintf(
		"%s%s%s",
		DirectoryText.Render(dirPrefix),
		strings.Repeat(" ", spaces),
		HeaderTitle.Render(titleText),
	)

	// 2ª línea en pantalla estrecha
	if narrow {
		// Dividir el directorio en partes
		parts := strings.Split(currentDir, "/")
		lastPart := parts[len(parts)-1]
		parentDir := strings.Join(parts[:len(parts)-1], "/")
		if parentDir != "" {
			parentDir += "/"
		}
		header += "\n" + DirectoryText.Render(parentDir) + DirectoryDir.Render(lastPart)

		// Añadir new_text en una línea separada después del pwd
		// Reemplazar con el texto de subdirectorios y selección
		selector := GetCurrentSelector()
		var subdirText, selectedText string

		// Determinar el estado de los subdirectorios
		if selector.IncludeMode {
			subdirText = White.Render("Subdirectories: ") + Magenta.Render("Included")
		} else {
			subdirText = White.Render("Subdirectories: ") + Magenta.Render("Not included")
		}

		// Contar archivos y directorios seleccionados
		selectedFiles, selectedDirs := countSelected(selector)
		selectedText = White.Render("Selected: ") +
			Magenta.Render(fmt.Sprintf("%d", selectedFiles)) +
			White.Render(" Files") +
			White.Render(", ") +
			Magenta.Render(fmt.Sprintf("%d", selectedDirs)) +
			White.Render(" Directories")

		// Texto completo con Selected justo después de Included/Not included
		infoText := subdirText + "   " + selectedText
		header += "\n" + infoText
	} else {
		// Dividir el directorio en partes
		parts := strings.Split(currentDir, "/")
		lastPart := parts[len(parts)-1]
		parentDir := strings.Join(parts[:len(parts)-1], "/")
		if parentDir != "" {
			parentDir += "/"
		}
		inLineSpaces := width - len(dirPrefix) - len(currentDir) - len(titleText)
		header = fmt.Sprintf(
			"%s%s%s%s%s",
			DirectoryText.Render(dirPrefix),
			DirectoryText.Render(parentDir),
			DirectoryDir.Render(lastPart),
			strings.Repeat(" ", inLineSpaces),
			HeaderTitle.Render(titleText),
		)

		// Añadir un salto de línea y luego el texto informativo
		// Reemplazar con el texto de subdirectorios y selección
		selector := GetCurrentSelector()
		var subdirText, selectedText string

		// Determinar el estado de los subdirectorios
		if selector.IncludeMode {
			subdirText = White.Render("Subdirectories: ") + Magenta.Render("Included")
		} else {
			subdirText = White.Render("Subdirectories: ") + White.Render("Not included")
		}

		// Contar archivos y directorios seleccionados
		selectedFiles, selectedDirs := countSelected(selector)
		selectedText = White.Render("Selected: ") +
			Magenta.Render(fmt.Sprintf("%d", selectedFiles)) +
			White.Render(" Files") +
			White.Render(", ") +
			Magenta.Render(fmt.Sprintf("%d", selectedDirs)) +
			White.Render(" Directories")

		// Texto completo con Selected justo después de Included/Not included
		infoText := subdirText + "   " + selectedText
		header += "\n" + infoText
	}

	// Añadir un último salto de línea antes de los paneles
	header += "\n"

	// Obtener el selector actual
	selector := GetCurrentSelector()

	// Comprobar si hay un mensaje de estado para mostrar
	if selector != nil && selector.StatusMessage != "" && time.Now().Unix()-selector.StatusTime < 5 {
		// Mostrar el mensaje por 5 segundos
		statusStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#FFFF00")).Bold(true)
		header += statusStyle.Render(selector.StatusMessage) + "\n"
	}

	// Panel layout
	panelWidth := width / 3

	renderLeft := func(text string, isActive bool, isCounter bool) string {
		padding := panelWidth - lipgloss.Width(text)
		if padding < 0 {
			padding = 0
		}
		if isActive {
			return ActiveHeader.Render(text + strings.Repeat(" ", padding))
		}
		if isCounter {
			return Blue.Render(text) + strings.Repeat(" ", padding)
		}
		return Cyan.Render(text) + strings.Repeat(" ", padding)
	}

	// Obtener el selector actual para verificar el modo include
	// selector := GetCurrentSelector()
	includeModeText := ""
	// if selector.IncludeMode {
	// 	includeModeText = " [Include Mode]"
	// }

	// Contar elementos para cada panel
	var totalItems, totalFiles, totalSubdirs int
	var err error

	// Si estamos en el panel de directorios
	if activePanel == 1 && position >= 0 && position < len(items) {
		item := items[position]
		var selectedDir string
		if item == ".." {
			selectedDir = filepath.Dir(currentDir)
		} else if item == "." {
			selectedDir = currentDir
		} else {
			selectedDir = filepath.Join(currentDir, item)
		}
		totalItems, err = countItems(selectedDir)
		if err == nil {
			totalFiles, _ = countFiles(selectedDir)
			totalSubdirs, _ = countSubdirs(selectedDir)
		}
	} else {
		// Si estamos en el panel de archivos o no hay directorio seleccionado
		totalItems, err = countItems(currentDir)
		if err == nil {
			totalFiles, _ = countFiles(currentDir)
			totalSubdirs, _ = countSubdirs(currentDir)
		}
	}

	// Añadir contadores a los encabezados
	left := renderLeft("Directories"+includeModeText, activePanel == 1, false)
	middle := renderLeft("Files", activePanel == 2, false)
	right := renderLeft("Preview", activePanel == 3, false)

	// Añadir los contadores en una línea nueva
	leftCounter := renderLeft(fmt.Sprintf("%d items", totalItems), false, true)
	middleCounter := renderLeft(fmt.Sprintf("%d files", totalFiles), false, true)
	rightCounter := renderLeft(fmt.Sprintf("%d subdirs", totalSubdirs), false, true)

	// Combinar las cabeceras y contadores
	header += left + White.Render("│") + middle + White.Render("│") + right + "\n"
	header += leftCounter + White.Render("│") + middleCounter + White.Render("│") + rightCounter + "\n"

	// Panel izquierdo (Directories)
	selected := map[string]bool{}
	start := 0
	panelHeight := height - 6  // Ajustado para considerar la línea adicional
	active := activePanel == 1
	includeSubdirs := false

	leftPanel := renderLeftPanel(items, selected, currentDir, position, start, panelHeight, panelWidth, active, includeSubdirs)

	// Panel de archivos (Files)
	filePanel := renderFilePanel(files, position, panelWidth, height, panelHeight, activePanel, filePosition)

	// Panel derecho (Preview)
	rightPanel := renderPreviewPanel(currentDir, panelWidth, panelHeight, files, filePosition, activePanel, items, position)

	// Combinar los paneles horizontalmente
	var result strings.Builder
	result.WriteString(header)

	// Dividir los paneles en líneas
	leftLines := strings.Split(leftPanel, "\n")
	fileLines := strings.Split(filePanel, "\n")
	rightLines := strings.Split(rightPanel, "\n")

	// Encontrar el máximo número de líneas
	maxLines := len(leftLines)
	if len(fileLines) > maxLines {
		maxLines = len(fileLines)
	}
	if len(rightLines) > maxLines {
		maxLines = len(rightLines)
	}

	// Asegurarnos de que tengamos suficientes líneas
	for maxLines < panelHeight {
		leftLines = append(leftLines, "")
		fileLines = append(fileLines, "")
		rightLines = append(rightLines, "")
		maxLines++
	}

	// Combinar las líneas horizontalmente
	for i := 0; i < maxLines; i++ {
		leftLine := ""
		if i < len(leftLines) {
			leftLine = leftLines[i]
		}
		fileLine := ""
		if i < len(fileLines) {
			fileLine = fileLines[i]
		}
		rightLine := ""
		if i < len(rightLines) {
			rightLine = rightLines[i]
		}

		// Asegurar que cada línea tenga el ancho correcto
		leftLine = lipgloss.PlaceHorizontal(panelWidth, lipgloss.Left, leftLine)
		fileLine = lipgloss.PlaceHorizontal(panelWidth, lipgloss.Left, fileLine)
		rightLine = lipgloss.PlaceHorizontal(panelWidth, lipgloss.Left, rightLine)

		// Añadir líneas verticales blancas entre los paneles
		result.WriteString(leftLine + White.Render("│") + fileLine + White.Render("│") + rightLine + "\n")
	}

	return result.String()
}

// Esta función debería manejar el renderizado de los archivos
func renderFilePanel(files []string, position, panelWidth, height, panelHeight int, activePanel int, filePosition int) string {
	var b strings.Builder

	// Obtener el selector actual
	selector := GetCurrentSelector()

	// Verificar si el directorio actual o el directorio seleccionado está seleccionado
	currentDirSelected := selector.IsSelected(".")
	selectedDirSelected := false
	if selector.ActivePanel == 1 && selector.Position < len(selector.Filtered) {
		selectedItem := selector.Filtered[selector.Position]
		if selectedItem != ".." {
			selectedDirSelected = selector.IsSelected(selectedItem)
		}
	}

	for i := 0; i < panelHeight && i < len(files); i++ {
		file := files[i]
		icon := GetFileIcon(file)

		// Verificar si el archivo está seleccionado o si algún directorio padre está seleccionado
		isSelected := selector.IsFileSelected(file) || currentDirSelected || selectedDirSelected

		// Añadir asterisco si está seleccionado
		marker := "  "
		if isSelected {
			marker = " *"
		}

		line := icon + marker + file

		// Truncar el nombre del archivo si es demasiado largo
		maxWidth := panelWidth - 2 // Dejamos espacio para el scrollbar
		if lipgloss.Width(line) > maxWidth {
			// Calcular cuánto espacio tenemos para el nombre del archivo
			iconWidth := lipgloss.Width(icon + marker)
			availableWidth := maxWidth - iconWidth - 3 // 3 para "..."

			// Truncar el nombre del archivo
			if availableWidth > 0 {
				truncatedName := file
				if len(truncatedName) > availableWidth {
					truncatedName = truncatedName[:availableWidth] + "..."
				}
				line = icon + marker + truncatedName
			}
		}

		// Aplicar el estilo Focus si el panel está activo y este es el archivo seleccionado
		if activePanel == 2 && i == filePosition {
			// Rellenar hasta el ancho del panel
			padding := panelWidth - lipgloss.Width(line)
			if padding > 0 {
				line += strings.Repeat(" ", padding)
			}
			b.WriteString(Focus.Render(line) + "\n")
		} else if isSelected {
			// Aplicar estilo amarillo para archivos seleccionados
			b.WriteString(Yellow.Render(line) + "\n")
		} else {
			b.WriteString(White.Render(line) + "\n")
		}
	}

	return b.String()
}

// renderPreviewPanel muestra el contenido del archivo seleccionado o los subdirectorios
func renderPreviewPanel(dir string, width, height int, files []string, filePosition int, activePanel int, items []string, position int) string {
	var b strings.Builder

	// Obtener el selector actual
	selector := GetCurrentSelector()

	// Si el panel activo es el de directorios, mostrar subdirectorios
	if activePanel == 1 {
		// Determinar el directorio seleccionado
		var selectedDir string
		if position >= 0 && position < len(items) {
			item := items[position]
			if item == ".." {
				selectedDir = filepath.Dir(dir)
			} else if item == "." {
				selectedDir = dir
			} else {
				selectedDir = filepath.Join(dir, item)
			}
		} else {
			selectedDir = dir
		}

		// Verificar si el directorio existe y es accesible
		info, err := os.Stat(selectedDir)
		if err != nil || !info.IsDir() {
			return strings.Repeat(" ", width) + "\n"
		}

		// Leer los subdirectorios
		entries, err := os.ReadDir(selectedDir)
		if err != nil {
			return strings.Repeat(" ", width) + "\n"
		}

		// Filtrar solo directorios y ordenarlos
		var subdirs []string
		for _, entry := range entries {
			if entry.IsDir() {
				subdirs = append(subdirs, entry.Name())
			}
		}
		sort.Strings(subdirs)

		// Mostrar los subdirectorios
		for i := 0; i < height && i < len(subdirs); i++ {
			subdir := subdirs[i]
			icon := GetFileIcon(filepath.Join(selectedDir, subdir))

			// Verificar si el subdirectorio está seleccionado
			isSelected := selector.Selection[filepath.Join(selectedDir, subdir)]

			// Añadir el marcador correspondiente
			marker := "  "
			if isSelected {
				marker = " •"
			}

			line := icon + marker + subdir

			// Rellenar hasta el ancho del panel
			padding := width - lipgloss.Width(line)
			if padding > 0 {
				line += strings.Repeat(" ", padding)
			}

			// Aplicar el estilo correspondiente
			if isSelected {
				b.WriteString(Yellow.Render(line) + "\n")
			} else {
				b.WriteString(Green.Render(line) + "\n")
			}
		}

		// Rellenar con líneas vacías si es necesario
		for i := len(subdirs); i < height; i++ {
			b.WriteString(strings.Repeat(" ", width) + "\n")
		}
	} else {
		// Si estamos en el panel de archivos, mostrar el contenido del archivo seleccionado
		if len(files) > 0 && filePosition >= 0 && filePosition < len(files) {
			// Determinar el directorio actual para los archivos
			var currentDir string
			if position >= 0 && position < len(items) {
				item := items[position]
				if item == ".." {
					currentDir = filepath.Dir(dir)
				} else if item == "." {
					currentDir = dir
				} else {
					currentDir = filepath.Join(dir, item)
				}
			} else {
				currentDir = dir
			}

			filePath := filepath.Join(currentDir, files[filePosition])

			// Verificar si el archivo es binario o demasiado grande
			info, err := os.Stat(filePath)
			if err != nil {
				// Error al acceder al archivo
				showErrorMessage(&b, "No se puede acceder al archivo", filePath, width, height)
				return b.String()
			}

			// Verificar si es un archivo binario o demasiado grande
			if isBinaryFile(filePath) || info.Size() > 1024*1024 { // Más de 1MB
				showBinaryFileMessage(&b, filePath, info.Size(), width, height)
				return b.String()
			}

			// Leer el contenido del archivo
			content, err := os.ReadFile(filePath)
			if err == nil {
				// Convertir el contenido a string y limitar a las primeras líneas que quepan
				lines := strings.Split(string(content), "\n")

				// Limitar el número de líneas para evitar desbordamientos
				maxLines := height
				if len(lines) > maxLines {
					lines = lines[:maxLines]
				}

				for i := 0; i < len(lines); i++ {
					line := lines[i]

					// Sanitizar la línea para evitar caracteres problemáticos
					line = sanitizeLine(line)

					// Truncar la línea si es demasiado larga
					if lipgloss.Width(line) > width {
						line = line[:width-3] + "..."
					}

					// Rellenar hasta el ancho del panel
					padding := width - lipgloss.Width(line)
					if padding > 0 {
						line += strings.Repeat(" ", padding)
					}

					b.WriteString(White.Render(line) + "\n")
				}

				// Rellenar con líneas vacías si es necesario
				for i := len(lines); i < height; i++ {
					b.WriteString(strings.Repeat(" ", width) + "\n")
				}
			} else {
				// Error al leer el archivo
				showErrorMessage(&b, "No se puede leer el archivo", filePath, width, height)
			}
		} else {
			// Mensaje cuando no hay archivo seleccionado
			msg := "No hay archivo seleccionado"
			padding := width - lipgloss.Width(msg)
			if padding > 0 {
				msg += strings.Repeat(" ", padding)
			}
			b.WriteString(White.Render(msg) + "\n")

			// Rellenar con líneas vacías
			for i := 1; i < height; i++ {
				b.WriteString(strings.Repeat(" ", width) + "\n")
			}
		}
	}

	return b.String()
}

// isBinaryFile verifica si un archivo es binario
func isBinaryFile(filePath string) bool {
	// Abrir el archivo
	file, err := os.Open(filePath)
	if err != nil {
		return false
	}
	defer file.Close()

	// Leer los primeros 1024 bytes
	buf := make([]byte, 1024)
	n, err := file.Read(buf)
	if err != nil && err != io.EOF {
		return false
	}

	// Verificar si contiene caracteres nulos o demasiados caracteres no imprimibles
	nullCount := 0
	nonPrintableCount := 0
	for i := 0; i < n; i++ {
		if buf[i] == 0 {
			nullCount++
		}
		if buf[i] < 32 && buf[i] != '\t' && buf[i] != '\n' && buf[i] != '\r' {
			nonPrintableCount++
		}
	}

	// Si hay más de 10 caracteres nulos o más del 30% son no imprimibles, considerarlo binario
	return nullCount > 10 || float64(nonPrintableCount)/float64(n) > 0.3
}

// showErrorMessage muestra un mensaje de error formateado
func showErrorMessage(b *strings.Builder, prefix, filePath string, width, height int) {
	// Mensaje de error más informativo pero seguro
	errorMsg := prefix
	if len(filePath) > width-20 {
		errorMsg += ": " + filePath[:width-25] + "..."
	} else {
		errorMsg += ": " + filePath
	}

	// Asegurar que el mensaje no exceda el ancho del panel
	if lipgloss.Width(errorMsg) > width {
		errorMsg = errorMsg[:width-3] + "..."
	}

	// Rellenar hasta el ancho del panel
	padding := width - lipgloss.Width(errorMsg)
	if padding > 0 {
		errorMsg += strings.Repeat(" ", padding)
	}

	b.WriteString(White.Render(errorMsg) + "\n")

	// Rellenar con líneas vacías
	for i := 1; i < height; i++ {
		b.WriteString(strings.Repeat(" ", width) + "\n")
	}
}

// showBinaryFileMessage muestra un mensaje para archivos binarios
func showBinaryFileMessage(b *strings.Builder, filePath string, size int64, width, height int) {
	// Crear un mensaje informativo
	sizeStr := formatFileSize(size)

	// Primera línea: nombre del archivo
	line1 := "Binary file"
	if lipgloss.Width(line1) > width {
		line1 = line1[:width-3] + "..."
	}
	padding1 := width - lipgloss.Width(line1)
	if padding1 > 0 {
		line1 += strings.Repeat(" ", padding1)
	}
	b.WriteString(White.Render(line1) + "\n")

	// Segunda línea: tamaño del archivo
	line2 := "Size: " + sizeStr
	padding2 := width - lipgloss.Width(line2)
	if padding2 > 0 {
		line2 += strings.Repeat(" ", padding2)
	}
	b.WriteString(White.Render(line2) + "\n")

	// Tercera línea: mensaje informativo
	line3 := "Preview not available"
	padding3 := width - lipgloss.Width(line3)
	if padding3 > 0 {
		line3 += strings.Repeat(" ", padding3)
	}
	b.WriteString(White.Render(line3) + "\n")

	// Rellenar con líneas vacías
	for i := 3; i < height; i++ {
		b.WriteString(strings.Repeat(" ", width) + "\n")
	}
}

// formatFileSize formatea el tamaño de un archivo en una cadena legible
func formatFileSize(size int64) string {
	const unit = 1024
	if size < unit {
		return fmt.Sprintf("%d B", size)
	}

	div, exp := int64(unit), 0
	for n := size / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}

	return fmt.Sprintf("%.1f %cB", float64(size)/float64(div), "KMGTPE"[exp])
}

// sanitizeLine elimina caracteres problemáticos de una línea
func sanitizeLine(line string) string {
	// Reemplazar caracteres de control y otros caracteres problemáticos
	var result strings.Builder
	for _, r := range line {
		if r < 32 && r != '\t' && r != '\n' && r != '\r' {
			// Reemplazar caracteres de control con un espacio
			result.WriteRune(' ')
		} else {
			result.WriteRune(r)
		}
	}
	return result.String()
}

// Get the terminal size
func getTerminalSize() (int, int) {
	width, height, err := term.GetSize(int(os.Stdout.Fd()))
	if err != nil {
		width, height = 80, 24 // Default terminal size if error occurs
	}
	return width, height
}

func renderLeftPanel(items []string, selected map[string]bool, directory string, position, start, height, width int, active bool, includeSubdirs bool) string {
	var b strings.Builder

	end := start + height
	if end > len(items) {
		end = len(items)
	}

	// Obtener el selector actual
	selector := GetCurrentSelector()

	for i := start; i < end; i++ {
		item := items[i]
		fullPath := filepath.Join(directory, item)
		if item == ".." {
			fullPath = filepath.Dir(directory)
		}
		isSelected := false
		if item != ".." {
			itemKey := selector.GetSelectionKey(item)
			isSelected = selector.Selection[itemKey]
		}
		hasFocus := active && i == position

		marker := "  "
		if isSelected {
			marker = " •"
		}
		content := marker + item
		maxWidth := width - 3
		if lipgloss.Width(content) > maxWidth {
			content = content[:maxWidth-3] + "..."
		}

		icon := GetFileIcon(fullPath)
		line := icon + content

		// Rellenar hasta el ancho del panel
		padding := width - lipgloss.Width(line)
		if padding > 0 {
			line += strings.Repeat(" ", padding)
		}

		// Estilos
		if hasFocus {
			b.WriteString(Focus.Render(line) + "\n")
		} else if isSelected {
			b.WriteString(Yellow.Render(line) + "\n")
		} else {
			b.WriteString(Green.Render(line) + "\n")
		}
	}

	return b.String()
}

// Variable global para mantener el selector actual
var currentSelector *Selector

// Función para establecer el selector actual
func SetCurrentSelector(s *Selector) {
	currentSelector = s
}

// Función para obtener el selector actual
func GetCurrentSelector() *Selector {
	if currentSelector == nil {
		currentSelector = &Selector{
			Selection: make(map[string]bool),
		}
	}
	return currentSelector
}

// countItems cuenta el número total de elementos (archivos + subdirectorios) en un directorio
func countItems(dir string) (int, error) {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return 0, err
	}
	return len(entries), nil
}

// countFiles cuenta el número de archivos en un directorio
func countFiles(dir string) (int, error) {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return 0, err
	}
	count := 0
	for _, entry := range entries {
		if !entry.IsDir() {
			count++
		}
	}
	return count, nil
}

// countSubdirs cuenta el número de subdirectorios en un directorio
func countSubdirs(dir string) (int, error) {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return 0, err
	}
	count := 0
	for _, entry := range entries {
		if entry.IsDir() {
			count++
		}
	}
	return count, nil
}

// countSelected cuenta el número de archivos y directorios seleccionados
func countSelected(selector *Selector) (int, int) {
	selectedFiles := 0
	selectedDirs := 0

	for key, selected := range selector.Selection {
		if !selected {
			continue
		}

		// Verificar si es un directorio o un archivo
		fileInfo, err := os.Stat(key)
		if err != nil {
			continue
		}

		if fileInfo.IsDir() {
			selectedDirs++
		} else {
			selectedFiles++
		}
	}

	return selectedFiles, selectedDirs
}
// End of file core/draw.go

---------------------------------------------
// File core/icons.go
package core

import (
	"os"
	"path/filepath"
	"strings"
)

// GetFileIcon devuelve un icono apropiado según el tipo de archivo usando Nerd Fonts
func GetFileIcon(filePath string) string {
	// Verificar si es un directorio
	if info, err := os.Stat(filePath); err == nil && info.IsDir() {
		return "\uf07b" // 󰉋
	}

	// Obtener la extensión del archivo
	ext := strings.ToLower(filepath.Ext(filePath))

	// Mapeo de extensiones a iconos de Nerd Fonts
	switch ext {
	// Archivos de código
	case ".py":
		return "\ue235" // 󰆧
	case ".js":
		return "\ue74e" // 󰝎
	case ".java":
		return "\ue738" // 󰜸
	case ".c", ".cpp", ".h":
		return "\ue61d" // 󰘝
	case ".cs":
		return "\uf81a" // 󰠚
	case ".php":
		return "\ue73d" // 󰜽
	case ".rb":
		return "\ue21e" // 󰈞
	case ".go":
		return "\ue626" // 󰘦
	case ".swift":
		return "\ue755" // 󰝕
	case ".kt":
		return "\ue634" // 󰘴
	case ".ts":
		return "\ue628" // 󰘨
	// Scripts
	case ".sh", ".bat", ".ps1", ".cmd":
		return "\uf489" // 󰒉
	// Archivos de texto
	case ".txt", ".md", ".rst", ".log":
		return "\uf15c" // 󰅜
	// Archivos de configuración
	case ".json":
		return "\ue60b" // 󰘋
	case ".yml", ".yaml":
		return "\uf481" // 󰒁
	case ".xml":
		return "\uf72f" // 󰜯
	case ".ini", ".conf", ".cfg", ".toml":
		return "\uf013" // 󰀓
	// Imágenes
	case ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".svg", ".ico", ".tiff":
		return "\uf1c5" // 󰇅
	// Audio
	case ".mp3", ".wav", ".ogg", ".flac", ".aac":
		return "\uf001" // 󰀁
	// Video
	case ".mp4", ".avi", ".mov", ".wmv", ".flv", ".mkv":
		return "\uf03d" // 󰀽
	// Archivos comprimidos
	case ".zip", ".rar", ".7z", ".tar", ".gz", ".bz2":
		return "\uf1c6" // 󰇆
	// Documentos
	case ".pdf":
		return "\uf1c1" // 󰇁
	case ".doc", ".docx":
		return "\uf1c2" // 󰇂
	case ".xls", ".xlsx":
		return "\uf1c3" // 󰇃
	case ".ppt", ".pptx":
		return "\uf1c4" // 󰇄
	// Ejecutables
	case ".exe", ".app", ".dmg", ".msi":
		return "\uf2e0" // 󰋠
	// Archivos web
	case ".html", ".htm":
		return "\uf13b" // 󰄻
	case ".css":
		return "\ue42b" // 󰐫
	// Archivos de git
	case ".git", ".gitignore":
		return "\ue702" // 󰜂
	// Por defecto
	default:
		return "\uf15b" // 󰅛
	}
}
// End of file core/icons.go

---------------------------------------------
// File core/input.go
package core

import (
	"catexplore/export"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"time"
)

func CaptureInput(key string) string {
	// Aquí manejas las teclas que recibes
	switch key {
	case "j", "Down":
		return "down"
	case "k", "Up":
		return "up"
	default:
		return ""
	}
}

func HandleKeyPress(key string, position, itemCount int, selected map[string]bool, items []string, s *Selector) int {
	switch key {
	case "q":
		// Restaurar la terminal y salir
		fmt.Print("\033[?1049l")
		os.Exit(0)
	case "down", "j":
		if s.ActivePanel == 1 {
			position++
			if position >= itemCount {
				position = 0
			}
		} else if s.ActivePanel == 2 {
			s.FilePosition++
			if s.FilePosition >= len(s.Files) {
				s.FilePosition = 0
			}
		}
	case "up", "k":
		if s.ActivePanel == 1 {
			position--
			if position < 0 {
				position = itemCount - 1
			}
		} else if s.ActivePanel == 2 {
			s.FilePosition--
			if s.FilePosition < 0 {
				s.FilePosition = len(s.Files) - 1
			}
		}
	case "i":
		// Toggle del modo include
		s.IncludeMode = !s.IncludeMode
	case "o":
		// Exportar y abrir en aplicación externa
		selectedPaths := getSelectedPaths(s.Selection)
		excludedPaths := getExcludedPaths(s)
		outputFile := export.GenerateTextFile(
			selectedPaths,
			excludedPaths,
			s.IncludeMode,
			GetRootDirectory(),
			s.Directory,
		)
		if outputFile != "" {
			// Abrir el archivo sin salir del modo alternativo
			err := OpenTextFile(outputFile)

			// Mostrar mensaje de éxito o error
			if err == nil {
				s.StatusMessage = "Archivo abierto: " + filepath.Base(outputFile)
			} else {
				s.StatusMessage = "Error al abrir el archivo"
			}
			s.StatusTime = time.Now().Unix()
		}
	case "c":
		// Exportar, copiar al portapapeles y eliminar archivo
		selectedPaths := getSelectedPaths(s.Selection)
		excludedPaths := getExcludedPaths(s)
		outputFile := export.GenerateTextFile(
			selectedPaths,
			excludedPaths,
			s.IncludeMode,
			GetRootDirectory(),
			s.Directory,
		)

		if outputFile != "" {
			// Leer el contenido del archivo
			content, err := os.ReadFile(outputFile)
			if err == nil {
				// Copiar al portapapeles según el sistema operativo
				success := copyToClipboard(string(content))

				// Eliminar el archivo temporal
				os.Remove(outputFile)

				// Contar archivos seleccionados para el mensaje de estado
				selectedFiles := countSelectedFiles(s)

				// Preparar mensaje y guardar estado
				msg := ""
				if success {
					msg = fmt.Sprintf("%d archivos copiados al portapapeles", selectedFiles)
				} else {
					msg = "Error al copiar al portapapeles"
				}
				s.StatusMessage = msg
				s.StatusTime = time.Now().Unix()
			}
		}
	case "tab":
		// Guardar el panel anterior
		previousPanel := s.ActivePanel

		// Cambiar solo entre los paneles de directorios y archivos (1 y 2)
		if s.ActivePanel == 1 {
			s.ActivePanel = 2
		} else {
			s.ActivePanel = 1
		}

		// Solo actualizar los archivos cuando cambiamos del panel de directorios al panel de archivos
		if previousPanel == 1 && s.ActivePanel == 2 {
			// Si venimos del panel de directorios, actualizar los archivos del directorio seleccionado
			if position >= 0 && position < len(items) {
				item := items[position]
				var selectedDir string
				if item == ".." {
					selectedDir = filepath.Dir(s.Directory)
				} else if item == "." {
					selectedDir = s.Directory
				} else {
					selectedDir = filepath.Join(s.Directory, item)
				}

				// Verificar si el directorio existe y es accesible
				if info, err := os.Stat(selectedDir); err == nil && info.IsDir() {
					// Actualizar la lista de archivos para el directorio seleccionado
					files, err := os.ReadDir(selectedDir)
					if err == nil {
						var fileList []string
						for _, file := range files {
							if !file.IsDir() { // Solo archivos
								fileList = append(fileList, file.Name())
							}
						}
						s.Files = fileList // Actualizamos los archivos
						s.FilePosition = 0 // Resetear la posición en el panel de archivos
					} else {
						s.Files = []string{} // Si hay error, limpiamos la lista de archivos
					}
				}
			}
		} else if s.ActivePanel == 2 && len(s.Files) > 0 {
			// Si ya estamos en el panel de archivos, solo resetear la posición
			s.FilePosition = 0
		}
	case "enter", "l":
		if s.ActivePanel == 1 && position >= 0 && position < len(items) {
			item := items[position]
			var newDir string
			if item == ".." {
				newDir = filepath.Dir(s.Directory)
			} else if item == "." {
				newDir = s.Directory
			} else {
				newDir = filepath.Join(s.Directory, item)
			}

			// Verificar si el directorio existe y es accesible
			if info, err := os.Stat(newDir); err == nil && info.IsDir() {
				// Guardar el estado actual en el historial antes de cambiar
				s.History = append(s.History, NavigationHistory{
					Directory: s.Directory,
					Position:  position,
				})

				s.Directory = newDir
				s.Filtered = PrepareDirItems(newDir)

				// Buscar la posición de "." en la nueva lista
				for i, item := range s.Filtered {
					if item == "." {
						position = i
						s.Position = i
						break
					}
				}

				items = s.Filtered // Actualizar los items con los nuevos
			}
		}
	case "esc", "h":
		// Navegar hacia atrás si no estamos en el directorio raíz de la aplicación
		rootDir := GetRootDirectory()
		if s.Directory != rootDir && len(s.History) > 0 {
			// Obtener el último estado del historial
			lastState := s.History[len(s.History)-1]

			// Verificar si el directorio del historial existe y es accesible
			if info, err := os.Stat(lastState.Directory); err == nil && info.IsDir() {
				s.Directory = lastState.Directory
				s.Filtered = PrepareDirItems(lastState.Directory)
				position = lastState.Position
				s.Position = lastState.Position
				items = s.Filtered

				// Eliminar el último estado del historial
				s.History = s.History[:len(s.History)-1]
			}
		}
	case "s":
		if s.ActivePanel == 1 {
			// Toggle de selección del directorio actual
			if position >= 0 && position < len(items) {
				item := items[position]
				if item != ".." {
					// Obtener el selector actual
					selector := GetCurrentSelector()

					// Determinar el estado actual de selección
					isSelected := selector.IsSelected(item)

					// Procesar el directorio actual
					dirPath := filepath.Join(s.Directory, item)
					processDirectoryRecursive(selector, dirPath, item, !isSelected)

					// Actualizar la lista de archivos si es necesario
					if !isSelected {
						// Si estamos seleccionando, actualizar la lista de archivos
						UpdateFileList(selector, s.Directory, item)
					} else {
						// Si estamos deseleccionando, limpiar la lista de archivos
						s.Files = []string{}
						s.FilePosition = 0
					}
				}
			}
		} else if s.ActivePanel == 2 && s.FilePosition >= 0 && s.FilePosition < len(s.Files) {
			// Obtener el nombre del archivo seleccionado
			selectedFile := s.Files[s.FilePosition]
			// Cambiar el estado de selección
			fileKey := s.GetFileSelectionKey(selectedFile)
			s.Selection[fileKey] = !s.Selection[fileKey]
		}
	case "a":
		if s.ActivePanel == 1 {
			// Verificar si todos los directorios están seleccionados (excluyendo '..' y '.')
			allSelected := true
			for _, item := range items {
				if item != ".." && item != "." && !s.IsSelected(item) {
					allSelected = false
					break
				}
			}

			// Si todos están seleccionados, deseleccionar todos (excluyendo '..' y '.')
			// Si no todos están seleccionados, seleccionar todos (excluyendo '..' y '.')
			for _, item := range items {
				if item != ".." && item != "." {
					// Procesar el directorio y sus subdirectorios si el modo include está activo
					dirPath := filepath.Join(s.Directory, item)
					processDirectoryRecursive(s, dirPath, item, !allSelected)
				}
			}
		} else if s.ActivePanel == 2 {
			// Verificar si todos los archivos están seleccionados
			allSelected := true
			for _, file := range s.Files {
				fileKey := s.GetFileSelectionKey(file)
				if !s.Selection[fileKey] {
					allSelected = false
					break
				}
			}

			// Si todos están seleccionados, deseleccionar todos
			// Si no todos están seleccionados, seleccionar todos
			for _, file := range s.Files {
				fileKey := s.GetFileSelectionKey(file)
				s.Selection[fileKey] = !allSelected
			}
		}
	}

	// Actualizar la posición en el selector
	s.Position = position

	// Actualizar los archivos cuando se navega
	s.UpdateFilesForCurrentDirectory()

	return position
}

// UpdateFileList actualiza la lista de archivos para un directorio
func UpdateFileList(selector *Selector, currentDir string, item string) {
	dirPath := filepath.Join(currentDir, item)
	files, err := os.ReadDir(dirPath)
	if err == nil {
		var fileList []string
		for _, file := range files {
			if !file.IsDir() { // Solo archivos
				fileList = append(fileList, file.Name())
			}
		}
		selector.Files = fileList
	}
}

// Función para obtener una lista de rutas seleccionadas
func getSelectedPaths(selection map[string]bool) []string {
	var paths []string
	for path, selected := range selection {
		if selected {
			paths = append(paths, path)
		}
	}
	return paths
}

// Función para obtener las rutas excluidas
func getExcludedPaths(s *Selector) []string {
	// Esta implementación dependerá de cómo manejes las exclusiones en tu modelo
	// Por ahora, retorna una lista vacía
	return []string{}
}

// Contar archivos seleccionados
func countSelectedFiles(s *Selector) int {
	count := 0
	for path, selected := range s.Selection {
		if selected {
			info, err := os.Stat(path)
			if err == nil {
				if !info.IsDir() {
					count++
				} else if s.IncludeMode {
					// Contar archivos en el directorio si IncludeMode está activo
					filepath.Walk(path, func(p string, info os.FileInfo, err error) error {
						if err == nil && !info.IsDir() {
							count++
						}
						return nil
					})
				} else {
					// Contar solo archivos en el nivel superior del directorio
					files, err := os.ReadDir(path)
					if err == nil {
						for _, file := range files {
							fileInfo, err := file.Info()
							if err == nil && !fileInfo.IsDir() {
								count++
							}
						}
					}
				}
			}
		}
	}
	return count
}

// Función para copiar al portapapeles
func copyToClipboard(text string) bool {
	var cmd *exec.Cmd

	switch runtime.GOOS {
	case "darwin": // macOS
		cmd = exec.Command("pbcopy")
	case "windows":
		// En Windows, necesitarías usar otro método, como el paquete clipboard
		// Por ahora, devolvemos falso como indicación de que no se soporta
		return false
	default: // Linux y otros
		// Primero intentar con xclip
		if _, err := exec.LookPath("xclip"); err == nil {
			cmd = exec.Command("xclip", "-selection", "clipboard")
		} else if _, err := exec.LookPath("xsel"); err == nil {
			// Luego intentar con xsel
			cmd = exec.Command("xsel", "--clipboard", "--input")
		} else if _, err := exec.LookPath("wl-copy"); err == nil {
			// Luego intentar con wl-copy (Wayland)
			cmd = exec.Command("wl-copy")
		} else {
			// No se encontró ninguna utilidad de portapapeles
			return false
		}
	}

	if cmd == nil {
		return false
	}

	// Crear un pipe para pasar el texto al comando
	pipe, err := cmd.StdinPipe()
	if err != nil {
		return false
	}

	// Iniciar el comando
	if err := cmd.Start(); err != nil {
		return false
	}

	// Escribir el texto en el pipe
	_, err = pipe.Write([]byte(text))
	if err != nil {
		return false
	}

	// Cerrar el pipe
	pipe.Close()

	// Esperar a que termine el comando
	return cmd.Wait() == nil
}
// End of file core/input.go

---------------------------------------------
// File core/model.go
package core
// End of file core/model.go

---------------------------------------------
// File core/process.go
package core

import (
	"os"
	"path/filepath"
)

// Función recursiva para procesar directorios y archivos
func processDirectoryRecursive(selector *Selector, dirPath string, item string, selectState bool) {
	// Actualizar el estado de selección del directorio actual
	selectionKey := selector.GetSelectionKey(item)
	selector.Selection[selectionKey] = selectState

	// Si el modo include está activado, procesar recursivamente los subdirectorios
	if selector.IncludeMode {
		// Leer el contenido del directorio
		entries, err := os.ReadDir(dirPath)
		if err == nil {
			for _, entry := range entries {
				if entry.IsDir() {
					// Procesar recursivamente el subdirectorio
					subDirPath := filepath.Join(dirPath, entry.Name())
					subItem := filepath.Join(item, entry.Name())
					processDirectoryRecursive(selector, subDirPath, subItem, selectState)
				} else {
					// Seleccionar archivos en el directorio actual
					fileKey := filepath.Join(dirPath, entry.Name())
					selector.Selection[fileKey] = selectState
				}
			}
		}
	} else {
		// Comportamiento original: solo seleccionar archivos en el directorio actual
		entries, err := os.ReadDir(dirPath)
		if err == nil {
			for _, entry := range entries {
				if !entry.IsDir() {
					fileKey := filepath.Join(dirPath, entry.Name())
					selector.Selection[fileKey] = selectState
				}
			}
		}
	}
}
// End of file core/process.go

---------------------------------------------
// File core/selector.go
package core

import (
	"os"
	"path/filepath"
)

// Estructura para mantener el historial de navegación
type NavigationHistory struct {
	Directory string
	Position  int
}

// Estructura Selector con los campos necesarios
type Selector struct {
	Directory    string            // Directorio actual
	ActivePanel  int               // Panel activo: 1 - Directorios, 2 - Archivos, 3 - Vista previa
	Position     int               // Posición actual en el panel de directorios
	FilePosition int               // Posición actual en el panel de archivos
	Selection    map[string]bool   // Items seleccionados (clave: ruta relativa al directorio actual)
	Filtered     []string          // Items filtrados para mostrar
	Files        []string          // Archivos en el subdirectorio actual
	History      []NavigationHistory // Historial de navegación
	IncludeMode  bool              // Modo de inclusión de subdirectorios
	StatusMessage string           // Mensaje de estado para mostrar al usuario
	StatusTime   int64             // Tiempo en que se estableció el mensaje de estado
}

// Método para actualizar los archivos del directorio seleccionado
func (s *Selector) UpdateFilesForCurrentDirectory() {
	// Si estamos en el panel de directorios, actualizar los archivos del directorio seleccionado
	if s.ActivePanel == 1 && s.Position < len(s.Filtered) {
		item := s.Filtered[s.Position]
		var dir string
		if item == ".." {
			dir = filepath.Dir(s.Directory)
		} else if item == "." {
			dir = s.Directory
		} else {
			dir = filepath.Join(s.Directory, item)
		}

		// Actualizar la lista de archivos para el directorio seleccionado
		files, err := os.ReadDir(dir)
		if err == nil {
			var fileList []string
			for _, file := range files {
				if !file.IsDir() { // Solo archivos
					fileList = append(fileList, file.Name())
				}
			}
			s.Files = fileList // Actualizamos los archivos
		} else {
			s.Files = []string{} // Si hay error, limpiamos la lista de archivos
		}
	}
	// No actualizamos los archivos cuando estamos en el panel de archivos
}

// Obtiene la clave de selección para un elemento, combinando el directorio actual con el nombre del elemento
func (s *Selector) GetSelectionKey(item string) string {
	if item == "." || item == ".." {
		return item
	}
	return filepath.Join(s.Directory, item)
}

// Obtiene la clave de selección para un archivo, teniendo en cuenta el directorio activo
func (s *Selector) GetFileSelectionKey(file string) string {
	// Si estamos en el panel de archivos, el archivo está en el directorio seleccionado
	if s.ActivePanel == 2 && s.Position < len(s.Filtered) {
		// Determinar el directorio actual para los archivos
		item := s.Filtered[s.Position]
		var currentDir string

		if item == ".." {
			currentDir = filepath.Dir(s.Directory)
		} else if item == "." {
			currentDir = s.Directory
		} else {
			currentDir = filepath.Join(s.Directory, item)
		}

		return filepath.Join(currentDir, file)
	}

	// Por defecto, asumimos que el archivo está en el directorio actual
	return filepath.Join(s.Directory, file)
}

// Verifica si un elemento está seleccionado
func (s *Selector) IsSelected(item string) bool {
	key := s.GetSelectionKey(item)
	// Si el elemento es un directorio y está seleccionado, todos sus archivos también están seleccionados
	if s.Selection[key] {
		return true
	}

	// Si el elemento es un archivo, verificar si su directorio padre está seleccionado
	parentDir := filepath.Dir(key)
	return s.Selection[parentDir]
}

// Verifica si un archivo está seleccionado
func (s *Selector) IsFileSelected(file string) bool {
	key := s.GetFileSelectionKey(file)
	// Verificar si el archivo está seleccionado directamente
	if s.Selection[key] {
		return true
	}

	// Verificar si el directorio padre está seleccionado
	parentDir := filepath.Dir(key)
	return s.Selection[parentDir]
}

// Función recursiva para procesar directorios y archivos
func processDirectory(selector *Selector, dirPath string, item string, selectState bool) {
	// Actualizar el estado de selección del directorio actual
	selectionKey := selector.GetSelectionKey(item)
	selector.Selection[selectionKey] = selectState

	// Si el modo include está activado, procesar recursivamente los subdirectorios
	if selector.IncludeMode {
		// Leer el contenido del directorio
		entries, err := os.ReadDir(dirPath)
		if err == nil {
			for _, entry := range entries {
				if entry.IsDir() {
					// Procesar recursivamente el subdirectorio
					subDirPath := filepath.Join(dirPath, entry.Name())
					subItem := filepath.Join(item, entry.Name())
					processDirectory(selector, subDirPath, subItem, selectState)
				} else {
					// Seleccionar archivos en el directorio actual
					fileKey := filepath.Join(dirPath, entry.Name())
					selector.Selection[fileKey] = selectState
				}
			}
		}
	} else {
		// Comportamiento original: solo seleccionar archivos en el directorio actual
		entries, err := os.ReadDir(dirPath)
		if err == nil {
			for _, entry := range entries {
				if !entry.IsDir() {
					fileKey := filepath.Join(dirPath, entry.Name())
					selector.Selection[fileKey] = selectState
				}
			}
		}
	}
}
// End of file core/selector.go

---------------------------------------------
// File core/styles.go
// core/styles.go
package core

import "github.com/charmbracelet/lipgloss"

// Colors
var (
	// Directories
	Green = lipgloss.NewStyle().Foreground(lipgloss.Color("2"))
	// Panel Headers
	Cyan = lipgloss.NewStyle().Foreground(lipgloss.Color("6"))
	// Files
	White = lipgloss.NewStyle().Foreground(lipgloss.Color("7"))
	// Selected item
	// Marked items
	Marked = lipgloss.NewStyle().Foreground(lipgloss.Color("11")).Background(lipgloss.Color("0"))
	// Headers
	Header = lipgloss.NewStyle().Foreground(lipgloss.Color("6")).Background(lipgloss.Color("0"))
	// Active panel header
	ActiveHeader = lipgloss.NewStyle().Foreground(lipgloss.Color("0")).Background(lipgloss.Color("6"))
	// Directory icon
	DirectoryIcon = lipgloss.NewStyle().Foreground(lipgloss.Color("11")).Background(lipgloss.Color("0"))
	// File icon
	FileIcon = lipgloss.NewStyle().Foreground(lipgloss.Color("12")).Background(lipgloss.Color("0"))
	// Key hints
	KeyHints = lipgloss.NewStyle().Foreground(lipgloss.Color("13")).Background(lipgloss.Color("0"))
	// Key hint text
	KeyHintText = lipgloss.NewStyle().Foreground(lipgloss.Color("15")).Background(lipgloss.Color("0"))
	// Magenta text
	Magenta = lipgloss.NewStyle().Foreground(lipgloss.Color("13"))
	// Yellow text for selected files
	Yellow = lipgloss.NewStyle().Foreground(lipgloss.Color("3"))
	// Blue text for counters
	Blue = lipgloss.NewStyle().Foreground(lipgloss.Color("4"))
)

// Styles for the layout (combined into one block)
var (
	// Directory text and the directory display
	DirectoryText = lipgloss.NewStyle().Foreground(lipgloss.Color("7"))
	DirectoryDir  = lipgloss.NewStyle().Foreground(lipgloss.Color("3"))
	// Title on the right (Cat Explorer)
	HeaderTitle = lipgloss.NewStyle().Foreground(lipgloss.Color("3"))
)


var (
	Focus = lipgloss.NewStyle().
	Foreground(lipgloss.Color("0")).
	Background(lipgloss.Color("7")) // blanco
	Selected = lipgloss.NewStyle().Foreground(lipgloss.Color("212"))
)
// End of file core/styles.go

---------------------------------------------
// File core/utils.go
package core

import (
	"os"
	"os/exec"
	"runtime"
	"sort"
)

var rootDirectory string

func OpenTextFile(path string) error {
	var cmd *exec.Cmd

	switch runtime.GOOS {
	case "darwin": // macOS
		cmd = exec.Command("open", path)
	case "windows": // Windows
		cmd = exec.Command("cmd", "/c", "start", "", path)
	default: // Linux y otros
		// Intentar xdg-open (estándar para la mayoría de distribuciones Linux)
		if _, err := exec.LookPath("xdg-open"); err == nil {
			cmd = exec.Command("xdg-open", path)
		} else if _, err := exec.LookPath("gnome-open"); err == nil {
			cmd = exec.Command("gnome-open", path)
		} else if _, err := exec.LookPath("kde-open"); err == nil {
			cmd = exec.Command("kde-open", path)
		} else {
			return os.ErrNotExist
		}
	}

	return cmd.Start()
}

// GetRootDirectory devuelve el directorio desde donde se ejecuta la aplicación
func GetRootDirectory() string {
	if rootDirectory == "" {
		dir, err := os.Getwd()
		if err != nil {
			rootDirectory = "/"
		} else {
			rootDirectory = dir
		}
	}
	return rootDirectory
}

func PrepareDirItems(pwd string) []string {
	files, _ := os.ReadDir(pwd)
	var dirs []string
	for _, f := range files {
		if f.IsDir() {
			dirs = append(dirs, f.Name())
		}
	}
	sort.Strings(dirs)

	// Añadir ".." como primer item si no estamos en el directorio root
	rootDir := GetRootDirectory()
	if pwd != rootDir {
		return append([]string{"..", "."}, dirs...)
	}
	return append([]string{"."}, dirs...)
}

// Get the current directory
func GetCurrentDirectory() string {
	dir, err := os.Getwd()
	if err != nil {
		return "/" // Return root if there's an error getting the current directory
	}
	return dir
}
// End of file core/utils.go

---------------------------------------------
// File core/draw.go
package core

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/charmbracelet/lipgloss"
	"golang.org/x/term"
)

func DrawLayout(position int, items []string, currentDir string, files []string, activePanel int, filePosition int) string {
	width, height := getTerminalSize()
	dirPrefix := "Directory: "
	titleText := "Cat Explorer"
	minSpacing := 2

	available := width - len(dirPrefix) - len(titleText) - minSpacing
	narrow := len(currentDir) > available

	// 1ª línea: prefijo + espacios + título
	spaces := width - len(dirPrefix) - len(titleText)
	if spaces < minSpacing {
		spaces = minSpacing
	}
	header := fmt.Sprintf(
		"%s%s%s",
		DirectoryText.Render(dirPrefix),
		strings.Repeat(" ", spaces),
		HeaderTitle.Render(titleText),
	)

	// 2ª línea en pantalla estrecha
	if narrow {
		// Dividir el directorio en partes
		parts := strings.Split(currentDir, "/")
		lastPart := parts[len(parts)-1]
		parentDir := strings.Join(parts[:len(parts)-1], "/")
		if parentDir != "" {
			parentDir += "/"
		}
		header += "\n" + DirectoryText.Render(parentDir) + DirectoryDir.Render(lastPart)

		// Añadir new_text en una línea separada después del pwd
		// Reemplazar con el texto de subdirectorios y selección
		selector := GetCurrentSelector()
		var subdirText, selectedText string

		// Determinar el estado de los subdirectorios
		if selector.IncludeMode {
			subdirText = White.Render("Subdirectories: ") + Magenta.Render("Included")
		} else {
			subdirText = White.Render("Subdirectories: ") + Magenta.Render("Not included")
		}

		// Contar archivos y directorios seleccionados
		selectedFiles, selectedDirs := countSelected(selector)
		selectedText = White.Render("Selected: ") +
			Magenta.Render(fmt.Sprintf("%d", selectedFiles)) +
			White.Render(" Files") +
			White.Render(", ") +
			Magenta.Render(fmt.Sprintf("%d", selectedDirs)) +
			White.Render(" Directories")

		// Texto completo con Selected justo después de Included/Not included
		infoText := subdirText + "   " + selectedText
		header += "\n" + infoText
	} else {
		// Dividir el directorio en partes
		parts := strings.Split(currentDir, "/")
		lastPart := parts[len(parts)-1]
		parentDir := strings.Join(parts[:len(parts)-1], "/")
		if parentDir != "" {
			parentDir += "/"
		}
		inLineSpaces := width - len(dirPrefix) - len(currentDir) - len(titleText)
		header = fmt.Sprintf(
			"%s%s%s%s%s",
			DirectoryText.Render(dirPrefix),
			DirectoryText.Render(parentDir),
			DirectoryDir.Render(lastPart),
			strings.Repeat(" ", inLineSpaces),
			HeaderTitle.Render(titleText),
		)

		// Añadir un salto de línea y luego el texto informativo
		// Reemplazar con el texto de subdirectorios y selección
		selector := GetCurrentSelector()
		var subdirText, selectedText string

		// Determinar el estado de los subdirectorios
		if selector.IncludeMode {
			subdirText = White.Render("Subdirectories: ") + Magenta.Render("Included")
		} else {
			subdirText = White.Render("Subdirectories: ") + White.Render("Not included")
		}

		// Contar archivos y directorios seleccionados
		selectedFiles, selectedDirs := countSelected(selector)
		selectedText = White.Render("Selected: ") +
			Magenta.Render(fmt.Sprintf("%d", selectedFiles)) +
			White.Render(" Files") +
			White.Render(", ") +
			Magenta.Render(fmt.Sprintf("%d", selectedDirs)) +
			White.Render(" Directories")

		// Texto completo con Selected justo después de Included/Not included
		infoText := subdirText + "   " + selectedText
		header += "\n" + infoText
	}

	// Añadir un último salto de línea antes de los paneles
	header += "\n"

	// Obtener el selector actual
	selector := GetCurrentSelector()

	// Comprobar si hay un mensaje de estado para mostrar
	if selector != nil && selector.StatusMessage != "" && time.Now().Unix()-selector.StatusTime < 5 {
		// Mostrar el mensaje por 5 segundos
		statusStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#FFFF00")).Bold(true)
		header += statusStyle.Render(selector.StatusMessage) + "\n"
	}

	// Panel layout
	panelWidth := width / 3

	renderLeft := func(text string, isActive bool, isCounter bool) string {
		padding := panelWidth - lipgloss.Width(text)
		if padding < 0 {
			padding = 0
		}
		if isActive {
			return ActiveHeader.Render(text + strings.Repeat(" ", padding))
		}
		if isCounter {
			return Blue.Render(text) + strings.Repeat(" ", padding)
		}
		return Cyan.Render(text) + strings.Repeat(" ", padding)
	}

	// Obtener el selector actual para verificar el modo include
	// selector := GetCurrentSelector()
	includeModeText := ""
	// if selector.IncludeMode {
	// 	includeModeText = " [Include Mode]"
	// }

	// Contar elementos para cada panel
	var totalItems, totalFiles, totalSubdirs int
	var err error

	// Si estamos en el panel de directorios
	if activePanel == 1 && position >= 0 && position < len(items) {
		item := items[position]
		var selectedDir string
		if item == ".." {
			selectedDir = filepath.Dir(currentDir)
		} else if item == "." {
			selectedDir = currentDir
		} else {
			selectedDir = filepath.Join(currentDir, item)
		}
		totalItems, err = countItems(selectedDir)
		if err == nil {
			totalFiles, _ = countFiles(selectedDir)
			totalSubdirs, _ = countSubdirs(selectedDir)
		}
	} else {
		// Si estamos en el panel de archivos o no hay directorio seleccionado
		totalItems, err = countItems(currentDir)
		if err == nil {
			totalFiles, _ = countFiles(currentDir)
			totalSubdirs, _ = countSubdirs(currentDir)
		}
	}

	// Añadir contadores a los encabezados
	left := renderLeft("Directories"+includeModeText, activePanel == 1, false)
	middle := renderLeft("Files", activePanel == 2, false)
	right := renderLeft("Preview", activePanel == 3, false)

	// Añadir los contadores en una línea nueva
	leftCounter := renderLeft(fmt.Sprintf("%d items", totalItems), false, true)
	middleCounter := renderLeft(fmt.Sprintf("%d files", totalFiles), false, true)
	rightCounter := renderLeft(fmt.Sprintf("%d subdirs", totalSubdirs), false, true)

	// Combinar las cabeceras y contadores
	header += left + White.Render("│") + middle + White.Render("│") + right + "\n"
	header += leftCounter + White.Render("│") + middleCounter + White.Render("│") + rightCounter + "\n"

	// Panel izquierdo (Directories)
	selected := map[string]bool{}
	start := 0
	panelHeight := height - 6  // Ajustado para considerar la línea adicional
	active := activePanel == 1
	includeSubdirs := false

	leftPanel := renderLeftPanel(items, selected, currentDir, position, start, panelHeight, panelWidth, active, includeSubdirs)

	// Panel de archivos (Files)
	filePanel := renderFilePanel(files, position, panelWidth, height, panelHeight, activePanel, filePosition)

	// Panel derecho (Preview)
	rightPanel := renderPreviewPanel(currentDir, panelWidth, panelHeight, files, filePosition, activePanel, items, position)

	// Combinar los paneles horizontalmente
	var result strings.Builder
	result.WriteString(header)

	// Dividir los paneles en líneas
	leftLines := strings.Split(leftPanel, "\n")
	fileLines := strings.Split(filePanel, "\n")
	rightLines := strings.Split(rightPanel, "\n")

	// Encontrar el máximo número de líneas
	maxLines := len(leftLines)
	if len(fileLines) > maxLines {
		maxLines = len(fileLines)
	}
	if len(rightLines) > maxLines {
		maxLines = len(rightLines)
	}

	// Asegurarnos de que tengamos suficientes líneas
	for maxLines < panelHeight {
		leftLines = append(leftLines, "")
		fileLines = append(fileLines, "")
		rightLines = append(rightLines, "")
		maxLines++
	}

	// Combinar las líneas horizontalmente
	for i := 0; i < maxLines; i++ {
		leftLine := ""
		if i < len(leftLines) {
			leftLine = leftLines[i]
		}
		fileLine := ""
		if i < len(fileLines) {
			fileLine = fileLines[i]
		}
		rightLine := ""
		if i < len(rightLines) {
			rightLine = rightLines[i]
		}

		// Asegurar que cada línea tenga el ancho correcto
		leftLine = lipgloss.PlaceHorizontal(panelWidth, lipgloss.Left, leftLine)
		fileLine = lipgloss.PlaceHorizontal(panelWidth, lipgloss.Left, fileLine)
		rightLine = lipgloss.PlaceHorizontal(panelWidth, lipgloss.Left, rightLine)

		// Añadir líneas verticales blancas entre los paneles
		result.WriteString(leftLine + White.Render("│") + fileLine + White.Render("│") + rightLine + "\n")
	}

	return result.String()
}

// Esta función debería manejar el renderizado de los archivos
func renderFilePanel(files []string, position, panelWidth, height, panelHeight int, activePanel int, filePosition int) string {
	var b strings.Builder

	// Obtener el selector actual
	selector := GetCurrentSelector()

	// Verificar si el directorio actual o el directorio seleccionado está seleccionado
	currentDirSelected := selector.IsSelected(".")
	selectedDirSelected := false
	if selector.ActivePanel == 1 && selector.Position < len(selector.Filtered) {
		selectedItem := selector.Filtered[selector.Position]
		if selectedItem != ".." {
			selectedDirSelected = selector.IsSelected(selectedItem)
		}
	}

	for i := 0; i < panelHeight && i < len(files); i++ {
		file := files[i]
		icon := GetFileIcon(file)

		// Verificar si el archivo está seleccionado o si algún directorio padre está seleccionado
		isSelected := selector.IsFileSelected(file) || currentDirSelected || selectedDirSelected

		// Añadir asterisco si está seleccionado
		marker := "  "
		if isSelected {
			marker = " *"
		}

		line := icon + marker + file

		// Truncar el nombre del archivo si es demasiado largo
		maxWidth := panelWidth - 2 // Dejamos espacio para el scrollbar
		if lipgloss.Width(line) > maxWidth {
			// Calcular cuánto espacio tenemos para el nombre del archivo
			iconWidth := lipgloss.Width(icon + marker)
			availableWidth := maxWidth - iconWidth - 3 // 3 para "..."

			// Truncar el nombre del archivo
			if availableWidth > 0 {
				truncatedName := file
				if len(truncatedName) > availableWidth {
					truncatedName = truncatedName[:availableWidth] + "..."
				}
				line = icon + marker + truncatedName
			}
		}

		// Aplicar el estilo Focus si el panel está activo y este es el archivo seleccionado
		if activePanel == 2 && i == filePosition {
			// Rellenar hasta el ancho del panel
			padding := panelWidth - lipgloss.Width(line)
			if padding > 0 {
				line += strings.Repeat(" ", padding)
			}
			b.WriteString(Focus.Render(line) + "\n")
		} else if isSelected {
			// Aplicar estilo amarillo para archivos seleccionados
			b.WriteString(Yellow.Render(line) + "\n")
		} else {
			b.WriteString(White.Render(line) + "\n")
		}
	}

	return b.String()
}

// renderPreviewPanel muestra el contenido del archivo seleccionado o los subdirectorios
func renderPreviewPanel(dir string, width, height int, files []string, filePosition int, activePanel int, items []string, position int) string {
	var b strings.Builder

	// Obtener el selector actual
	selector := GetCurrentSelector()

	// Si el panel activo es el de directorios, mostrar subdirectorios
	if activePanel == 1 {
		// Determinar el directorio seleccionado
		var selectedDir string
		if position >= 0 && position < len(items) {
			item := items[position]
			if item == ".." {
				selectedDir = filepath.Dir(dir)
			} else if item == "." {
				selectedDir = dir
			} else {
				selectedDir = filepath.Join(dir, item)
			}
		} else {
			selectedDir = dir
		}

		// Verificar si el directorio existe y es accesible
		info, err := os.Stat(selectedDir)
		if err != nil || !info.IsDir() {
			return strings.Repeat(" ", width) + "\n"
		}

		// Leer los subdirectorios
		entries, err := os.ReadDir(selectedDir)
		if err != nil {
			return strings.Repeat(" ", width) + "\n"
		}

		// Filtrar solo directorios y ordenarlos
		var subdirs []string
		for _, entry := range entries {
			if entry.IsDir() {
				subdirs = append(subdirs, entry.Name())
			}
		}
		sort.Strings(subdirs)

		// Mostrar los subdirectorios
		for i := 0; i < height && i < len(subdirs); i++ {
			subdir := subdirs[i]
			icon := GetFileIcon(filepath.Join(selectedDir, subdir))

			// Verificar si el subdirectorio está seleccionado
			isSelected := selector.Selection[filepath.Join(selectedDir, subdir)]

			// Añadir el marcador correspondiente
			marker := "  "
			if isSelected {
				marker = " •"
			}

			line := icon + marker + subdir

			// Rellenar hasta el ancho del panel
			padding := width - lipgloss.Width(line)
			if padding > 0 {
				line += strings.Repeat(" ", padding)
			}

			// Aplicar el estilo correspondiente
			if isSelected {
				b.WriteString(Yellow.Render(line) + "\n")
			} else {
				b.WriteString(Green.Render(line) + "\n")
			}
		}

		// Rellenar con líneas vacías si es necesario
		for i := len(subdirs); i < height; i++ {
			b.WriteString(strings.Repeat(" ", width) + "\n")
		}
	} else {
		// Si estamos en el panel de archivos, mostrar el contenido del archivo seleccionado
		if len(files) > 0 && filePosition >= 0 && filePosition < len(files) {
			// Determinar el directorio actual para los archivos
			var currentDir string
			if position >= 0 && position < len(items) {
				item := items[position]
				if item == ".." {
					currentDir = filepath.Dir(dir)
				} else if item == "." {
					currentDir = dir
				} else {
					currentDir = filepath.Join(dir, item)
				}
			} else {
				currentDir = dir
			}

			filePath := filepath.Join(currentDir, files[filePosition])

			// Verificar si el archivo es binario o demasiado grande
			info, err := os.Stat(filePath)
			if err != nil {
				// Error al acceder al archivo
				showErrorMessage(&b, "No se puede acceder al archivo", filePath, width, height)
				return b.String()
			}

			// Verificar si es un archivo binario o demasiado grande
			if isBinaryFile(filePath) || info.Size() > 1024*1024 { // Más de 1MB
				showBinaryFileMessage(&b, filePath, info.Size(), width, height)
				return b.String()
			}

			// Leer el contenido del archivo
			content, err := os.ReadFile(filePath)
			if err == nil {
				// Convertir el contenido a string y limitar a las primeras líneas que quepan
				lines := strings.Split(string(content), "\n")

				// Limitar el número de líneas para evitar desbordamientos
				maxLines := height
				if len(lines) > maxLines {
					lines = lines[:maxLines]
				}

				for i := 0; i < len(lines); i++ {
					line := lines[i]

					// Sanitizar la línea para evitar caracteres problemáticos
					line = sanitizeLine(line)

					// Truncar la línea si es demasiado larga
					if lipgloss.Width(line) > width {
						line = line[:width-3] + "..."
					}

					// Rellenar hasta el ancho del panel
					padding := width - lipgloss.Width(line)
					if padding > 0 {
						line += strings.Repeat(" ", padding)
					}

					b.WriteString(White.Render(line) + "\n")
				}

				// Rellenar con líneas vacías si es necesario
				for i := len(lines); i < height; i++ {
					b.WriteString(strings.Repeat(" ", width) + "\n")
				}
			} else {
				// Error al leer el archivo
				showErrorMessage(&b, "No se puede leer el archivo", filePath, width, height)
			}
		} else {
			// Mensaje cuando no hay archivo seleccionado
			msg := "No hay archivo seleccionado"
			padding := width - lipgloss.Width(msg)
			if padding > 0 {
				msg += strings.Repeat(" ", padding)
			}
			b.WriteString(White.Render(msg) + "\n")

			// Rellenar con líneas vacías
			for i := 1; i < height; i++ {
				b.WriteString(strings.Repeat(" ", width) + "\n")
			}
		}
	}

	return b.String()
}

// isBinaryFile verifica si un archivo es binario
func isBinaryFile(filePath string) bool {
	// Abrir el archivo
	file, err := os.Open(filePath)
	if err != nil {
		return false
	}
	defer file.Close()

	// Leer los primeros 1024 bytes
	buf := make([]byte, 1024)
	n, err := file.Read(buf)
	if err != nil && err != io.EOF {
		return false
	}

	// Verificar si contiene caracteres nulos o demasiados caracteres no imprimibles
	nullCount := 0
	nonPrintableCount := 0
	for i := 0; i < n; i++ {
		if buf[i] == 0 {
			nullCount++
		}
		if buf[i] < 32 && buf[i] != '\t' && buf[i] != '\n' && buf[i] != '\r' {
			nonPrintableCount++
		}
	}

	// Si hay más de 10 caracteres nulos o más del 30% son no imprimibles, considerarlo binario
	return nullCount > 10 || float64(nonPrintableCount)/float64(n) > 0.3
}

// showErrorMessage muestra un mensaje de error formateado
func showErrorMessage(b *strings.Builder, prefix, filePath string, width, height int) {
	// Mensaje de error más informativo pero seguro
	errorMsg := prefix
	if len(filePath) > width-20 {
		errorMsg += ": " + filePath[:width-25] + "..."
	} else {
		errorMsg += ": " + filePath
	}

	// Asegurar que el mensaje no exceda el ancho del panel
	if lipgloss.Width(errorMsg) > width {
		errorMsg = errorMsg[:width-3] + "..."
	}

	// Rellenar hasta el ancho del panel
	padding := width - lipgloss.Width(errorMsg)
	if padding > 0 {
		errorMsg += strings.Repeat(" ", padding)
	}

	b.WriteString(White.Render(errorMsg) + "\n")

	// Rellenar con líneas vacías
	for i := 1; i < height; i++ {
		b.WriteString(strings.Repeat(" ", width) + "\n")
	}
}

// showBinaryFileMessage muestra un mensaje para archivos binarios
func showBinaryFileMessage(b *strings.Builder, filePath string, size int64, width, height int) {
	// Crear un mensaje informativo
	sizeStr := formatFileSize(size)

	// Primera línea: nombre del archivo
	line1 := "Binary file"
	if lipgloss.Width(line1) > width {
		line1 = line1[:width-3] + "..."
	}
	padding1 := width - lipgloss.Width(line1)
	if padding1 > 0 {
		line1 += strings.Repeat(" ", padding1)
	}
	b.WriteString(White.Render(line1) + "\n")

	// Segunda línea: tamaño del archivo
	line2 := "Size: " + sizeStr
	padding2 := width - lipgloss.Width(line2)
	if padding2 > 0 {
		line2 += strings.Repeat(" ", padding2)
	}
	b.WriteString(White.Render(line2) + "\n")

	// Tercera línea: mensaje informativo
	line3 := "Preview not available"
	padding3 := width - lipgloss.Width(line3)
	if padding3 > 0 {
		line3 += strings.Repeat(" ", padding3)
	}
	b.WriteString(White.Render(line3) + "\n")

	// Rellenar con líneas vacías
	for i := 3; i < height; i++ {
		b.WriteString(strings.Repeat(" ", width) + "\n")
	}
}

// formatFileSize formatea el tamaño de un archivo en una cadena legible
func formatFileSize(size int64) string {
	const unit = 1024
	if size < unit {
		return fmt.Sprintf("%d B", size)
	}

	div, exp := int64(unit), 0
	for n := size / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}

	return fmt.Sprintf("%.1f %cB", float64(size)/float64(div), "KMGTPE"[exp])
}

// sanitizeLine elimina caracteres problemáticos de una línea
func sanitizeLine(line string) string {
	// Reemplazar caracteres de control y otros caracteres problemáticos
	var result strings.Builder
	for _, r := range line {
		if r < 32 && r != '\t' && r != '\n' && r != '\r' {
			// Reemplazar caracteres de control con un espacio
			result.WriteRune(' ')
		} else {
			result.WriteRune(r)
		}
	}
	return result.String()
}

// Get the terminal size
func getTerminalSize() (int, int) {
	width, height, err := term.GetSize(int(os.Stdout.Fd()))
	if err != nil {
		width, height = 80, 24 // Default terminal size if error occurs
	}
	return width, height
}

func renderLeftPanel(items []string, selected map[string]bool, directory string, position, start, height, width int, active bool, includeSubdirs bool) string {
	var b strings.Builder

	end := start + height
	if end > len(items) {
		end = len(items)
	}

	// Obtener el selector actual
	selector := GetCurrentSelector()

	for i := start; i < end; i++ {
		item := items[i]
		fullPath := filepath.Join(directory, item)
		if item == ".." {
			fullPath = filepath.Dir(directory)
		}
		isSelected := false
		if item != ".." {
			itemKey := selector.GetSelectionKey(item)
			isSelected = selector.Selection[itemKey]
		}
		hasFocus := active && i == position

		marker := "  "
		if isSelected {
			marker = " •"
		}
		content := marker + item
		maxWidth := width - 3
		if lipgloss.Width(content) > maxWidth {
			content = content[:maxWidth-3] + "..."
		}

		icon := GetFileIcon(fullPath)
		line := icon + content

		// Rellenar hasta el ancho del panel
		padding := width - lipgloss.Width(line)
		if padding > 0 {
			line += strings.Repeat(" ", padding)
		}

		// Estilos
		if hasFocus {
			b.WriteString(Focus.Render(line) + "\n")
		} else if isSelected {
			b.WriteString(Yellow.Render(line) + "\n")
		} else {
			b.WriteString(Green.Render(line) + "\n")
		}
	}

	return b.String()
}

// Variable global para mantener el selector actual
var currentSelector *Selector

// Función para establecer el selector actual
func SetCurrentSelector(s *Selector) {
	currentSelector = s
}

// Función para obtener el selector actual
func GetCurrentSelector() *Selector {
	if currentSelector == nil {
		currentSelector = &Selector{
			Selection: make(map[string]bool),
		}
	}
	return currentSelector
}

// countItems cuenta el número total de elementos (archivos + subdirectorios) en un directorio
func countItems(dir string) (int, error) {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return 0, err
	}
	return len(entries), nil
}

// countFiles cuenta el número de archivos en un directorio
func countFiles(dir string) (int, error) {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return 0, err
	}
	count := 0
	for _, entry := range entries {
		if !entry.IsDir() {
			count++
		}
	}
	return count, nil
}

// countSubdirs cuenta el número de subdirectorios en un directorio
func countSubdirs(dir string) (int, error) {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return 0, err
	}
	count := 0
	for _, entry := range entries {
		if entry.IsDir() {
			count++
		}
	}
	return count, nil
}

// countSelected cuenta el número de archivos y directorios seleccionados
func countSelected(selector *Selector) (int, int) {
	selectedFiles := 0
	selectedDirs := 0

	for key, selected := range selector.Selection {
		if !selected {
			continue
		}

		// Verificar si es un directorio o un archivo
		fileInfo, err := os.Stat(key)
		if err != nil {
			continue
		}

		if fileInfo.IsDir() {
			selectedDirs++
		} else {
			selectedFiles++
		}
	}

	return selectedFiles, selectedDirs
}
// End of file core/draw.go

---------------------------------------------
// File core/icons.go
package core

import (
	"os"
	"path/filepath"
	"strings"
)

// GetFileIcon devuelve un icono apropiado según el tipo de archivo usando Nerd Fonts
func GetFileIcon(filePath string) string {
	// Verificar si es un directorio
	if info, err := os.Stat(filePath); err == nil && info.IsDir() {
		return "\uf07b" // 󰉋
	}

	// Obtener la extensión del archivo
	ext := strings.ToLower(filepath.Ext(filePath))

	// Mapeo de extensiones a iconos de Nerd Fonts
	switch ext {
	// Archivos de código
	case ".py":
		return "\ue235" // 󰆧
	case ".js":
		return "\ue74e" // 󰝎
	case ".java":
		return "\ue738" // 󰜸
	case ".c", ".cpp", ".h":
		return "\ue61d" // 󰘝
	case ".cs":
		return "\uf81a" // 󰠚
	case ".php":
		return "\ue73d" // 󰜽
	case ".rb":
		return "\ue21e" // 󰈞
	case ".go":
		return "\ue626" // 󰘦
	case ".swift":
		return "\ue755" // 󰝕
	case ".kt":
		return "\ue634" // 󰘴
	case ".ts":
		return "\ue628" // 󰘨
	// Scripts
	case ".sh", ".bat", ".ps1", ".cmd":
		return "\uf489" // 󰒉
	// Archivos de texto
	case ".txt", ".md", ".rst", ".log":
		return "\uf15c" // 󰅜
	// Archivos de configuración
	case ".json":
		return "\ue60b" // 󰘋
	case ".yml", ".yaml":
		return "\uf481" // 󰒁
	case ".xml":
		return "\uf72f" // 󰜯
	case ".ini", ".conf", ".cfg", ".toml":
		return "\uf013" // 󰀓
	// Imágenes
	case ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".svg", ".ico", ".tiff":
		return "\uf1c5" // 󰇅
	// Audio
	case ".mp3", ".wav", ".ogg", ".flac", ".aac":
		return "\uf001" // 󰀁
	// Video
	case ".mp4", ".avi", ".mov", ".wmv", ".flv", ".mkv":
		return "\uf03d" // 󰀽
	// Archivos comprimidos
	case ".zip", ".rar", ".7z", ".tar", ".gz", ".bz2":
		return "\uf1c6" // 󰇆
	// Documentos
	case ".pdf":
		return "\uf1c1" // 󰇁
	case ".doc", ".docx":
		return "\uf1c2" // 󰇂
	case ".xls", ".xlsx":
		return "\uf1c3" // 󰇃
	case ".ppt", ".pptx":
		return "\uf1c4" // 󰇄
	// Ejecutables
	case ".exe", ".app", ".dmg", ".msi":
		return "\uf2e0" // 󰋠
	// Archivos web
	case ".html", ".htm":
		return "\uf13b" // 󰄻
	case ".css":
		return "\ue42b" // 󰐫
	// Archivos de git
	case ".git", ".gitignore":
		return "\ue702" // 󰜂
	// Por defecto
	default:
		return "\uf15b" // 󰅛
	}
}
// End of file core/icons.go

---------------------------------------------
// File core/process.go
package core

import (
	"os"
	"path/filepath"
)

// Función recursiva para procesar directorios y archivos
func processDirectoryRecursive(selector *Selector, dirPath string, item string, selectState bool) {
	// Actualizar el estado de selección del directorio actual
	selectionKey := selector.GetSelectionKey(item)
	selector.Selection[selectionKey] = selectState

	// Si el modo include está activado, procesar recursivamente los subdirectorios
	if selector.IncludeMode {
		// Leer el contenido del directorio
		entries, err := os.ReadDir(dirPath)
		if err == nil {
			for _, entry := range entries {
				if entry.IsDir() {
					// Procesar recursivamente el subdirectorio
					subDirPath := filepath.Join(dirPath, entry.Name())
					subItem := filepath.Join(item, entry.Name())
					processDirectoryRecursive(selector, subDirPath, subItem, selectState)
				} else {
					// Seleccionar archivos en el directorio actual
					fileKey := filepath.Join(dirPath, entry.Name())
					selector.Selection[fileKey] = selectState
				}
			}
		}
	} else {
		// Comportamiento original: solo seleccionar archivos en el directorio actual
		entries, err := os.ReadDir(dirPath)
		if err == nil {
			for _, entry := range entries {
				if !entry.IsDir() {
					fileKey := filepath.Join(dirPath, entry.Name())
					selector.Selection[fileKey] = selectState
				}
			}
		}
	}
}
// End of file core/process.go

---------------------------------------------
// File core/selector.go
package core

import (
	"os"
	"path/filepath"
)

// Estructura para mantener el historial de navegación
type NavigationHistory struct {
	Directory string
	Position  int
}

// Estructura Selector con los campos necesarios
type Selector struct {
	Directory    string            // Directorio actual
	ActivePanel  int               // Panel activo: 1 - Directorios, 2 - Archivos, 3 - Vista previa
	Position     int               // Posición actual en el panel de directorios
	FilePosition int               // Posición actual en el panel de archivos
	Selection    map[string]bool   // Items seleccionados (clave: ruta relativa al directorio actual)
	Filtered     []string          // Items filtrados para mostrar
	Files        []string          // Archivos en el subdirectorio actual
	History      []NavigationHistory // Historial de navegación
	IncludeMode  bool              // Modo de inclusión de subdirectorios
	StatusMessage string           // Mensaje de estado para mostrar al usuario
	StatusTime   int64             // Tiempo en que se estableció el mensaje de estado
}

// Método para actualizar los archivos del directorio seleccionado
func (s *Selector) UpdateFilesForCurrentDirectory() {
	// Si estamos en el panel de directorios, actualizar los archivos del directorio seleccionado
	if s.ActivePanel == 1 && s.Position < len(s.Filtered) {
		item := s.Filtered[s.Position]
		var dir string
		if item == ".." {
			dir = filepath.Dir(s.Directory)
		} else if item == "." {
			dir = s.Directory
		} else {
			dir = filepath.Join(s.Directory, item)
		}

		// Actualizar la lista de archivos para el directorio seleccionado
		files, err := os.ReadDir(dir)
		if err == nil {
			var fileList []string
			for _, file := range files {
				if !file.IsDir() { // Solo archivos
					fileList = append(fileList, file.Name())
				}
			}
			s.Files = fileList // Actualizamos los archivos
		} else {
			s.Files = []string{} // Si hay error, limpiamos la lista de archivos
		}
	}
	// No actualizamos los archivos cuando estamos en el panel de archivos
}

// Obtiene la clave de selección para un elemento, combinando el directorio actual con el nombre del elemento
func (s *Selector) GetSelectionKey(item string) string {
	if item == "." || item == ".." {
		return item
	}
	return filepath.Join(s.Directory, item)
}

// Obtiene la clave de selección para un archivo, teniendo en cuenta el directorio activo
func (s *Selector) GetFileSelectionKey(file string) string {
	// Si estamos en el panel de archivos, el archivo está en el directorio seleccionado
	if s.ActivePanel == 2 && s.Position < len(s.Filtered) {
		// Determinar el directorio actual para los archivos
		item := s.Filtered[s.Position]
		var currentDir string

		if item == ".." {
			currentDir = filepath.Dir(s.Directory)
		} else if item == "." {
			currentDir = s.Directory
		} else {
			currentDir = filepath.Join(s.Directory, item)
		}

		return filepath.Join(currentDir, file)
	}

	// Por defecto, asumimos que el archivo está en el directorio actual
	return filepath.Join(s.Directory, file)
}

// Verifica si un elemento está seleccionado
func (s *Selector) IsSelected(item string) bool {
	key := s.GetSelectionKey(item)
	// Si el elemento es un directorio y está seleccionado, todos sus archivos también están seleccionados
	if s.Selection[key] {
		return true
	}

	// Si el elemento es un archivo, verificar si su directorio padre está seleccionado
	parentDir := filepath.Dir(key)
	return s.Selection[parentDir]
}

// Verifica si un archivo está seleccionado
func (s *Selector) IsFileSelected(file string) bool {
	key := s.GetFileSelectionKey(file)
	// Verificar si el archivo está seleccionado directamente
	if s.Selection[key] {
		return true
	}

	// Verificar si el directorio padre está seleccionado
	parentDir := filepath.Dir(key)
	return s.Selection[parentDir]
}

// Función recursiva para procesar directorios y archivos
func processDirectory(selector *Selector, dirPath string, item string, selectState bool) {
	// Actualizar el estado de selección del directorio actual
	selectionKey := selector.GetSelectionKey(item)
	selector.Selection[selectionKey] = selectState

	// Si el modo include está activado, procesar recursivamente los subdirectorios
	if selector.IncludeMode {
		// Leer el contenido del directorio
		entries, err := os.ReadDir(dirPath)
		if err == nil {
			for _, entry := range entries {
				if entry.IsDir() {
					// Procesar recursivamente el subdirectorio
					subDirPath := filepath.Join(dirPath, entry.Name())
					subItem := filepath.Join(item, entry.Name())
					processDirectory(selector, subDirPath, subItem, selectState)
				} else {
					// Seleccionar archivos en el directorio actual
					fileKey := filepath.Join(dirPath, entry.Name())
					selector.Selection[fileKey] = selectState
				}
			}
		}
	} else {
		// Comportamiento original: solo seleccionar archivos en el directorio actual
		entries, err := os.ReadDir(dirPath)
		if err == nil {
			for _, entry := range entries {
				if !entry.IsDir() {
					fileKey := filepath.Join(dirPath, entry.Name())
					selector.Selection[fileKey] = selectState
				}
			}
		}
	}
}
// End of file core/selector.go

