package core

import (
	"catexplore/export"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"time"
)

func CaptureInput(key string) string {
	// Aquí manejas las teclas que recibes
	switch key {
	case "j", "Down":
		return "down"
	case "k", "Up":
		return "up"
	default:
		return ""
	}
}

func HandleKeyPress(key string, position, itemCount int, selected map[string]bool, items []string, s *Selector) int {
	switch key {
	case "q":
		// Restaurar la terminal y salir
		fmt.Print("\033[?1049l")
		os.Exit(0)
	case "down", "j":
		if s.ActivePanel == 1 {
			position++
			if position >= itemCount {
				position = 0
			}
		} else if s.ActivePanel == 2 {
			s.FilePosition++
			if s.FilePosition >= len(s.Files) {
				s.FilePosition = 0
			}
		}
	case "up", "k":
		if s.ActivePanel == 1 {
			position--
			if position < 0 {
				position = itemCount - 1
			}
		} else if s.ActivePanel == 2 {
			s.FilePosition--
			if s.FilePosition < 0 {
				s.FilePosition = len(s.Files) - 1
			}
		}
	case "i":
		// Toggle del modo include
		s.IncludeMode = !s.IncludeMode
	case "o":
		// Exportar y abrir en aplicación externa
		selectedPaths := getSelectedPaths(s.Selection)
		excludedPaths := getExcludedPaths(s)
		outputFile := export.GenerateTextFile(
			selectedPaths,
			excludedPaths,
			s.IncludeMode,
			GetRootDirectory(),
			s.Directory,
		)
		if outputFile != "" {
			// Abrir el archivo sin salir del modo alternativo
			err := OpenTextFile(outputFile)

			// Mostrar mensaje de éxito o error
			if err == nil {
				s.StatusMessage = "Archivo abierto: " + filepath.Base(outputFile)
			} else {
				s.StatusMessage = "Error al abrir el archivo"
			}
			s.StatusTime = time.Now().Unix()
		}
	case "c":
		// Exportar, copiar al portapapeles y eliminar archivo
		selectedPaths := getSelectedPaths(s.Selection)
		excludedPaths := getExcludedPaths(s)
		outputFile := export.GenerateTextFile(
			selectedPaths,
			excludedPaths,
			s.IncludeMode,
			GetRootDirectory(),
			s.Directory,
		)

		if outputFile != "" {
			// Leer el contenido del archivo
			content, err := os.ReadFile(outputFile)
			if err == nil {
				// Copiar al portapapeles según el sistema operativo
				success := copyToClipboard(string(content))

				// Eliminar el archivo temporal
				os.Remove(outputFile)

				// Contar archivos seleccionados para el mensaje de estado
				selectedFiles := countSelectedFiles(s)

				// Preparar mensaje y guardar estado
				msg := ""
				if success {
					msg = fmt.Sprintf("%d archivos copiados al portapapeles", selectedFiles)
				} else {
					msg = "Error al copiar al portapapeles"
				}
				s.StatusMessage = msg
				s.StatusTime = time.Now().Unix()
			}
		}
	case "tab":
		// Guardar el panel anterior
		previousPanel := s.ActivePanel

		// Cambiar solo entre los paneles de directorios y archivos (1 y 2)
		if s.ActivePanel == 1 {
			s.ActivePanel = 2
		} else {
			s.ActivePanel = 1
		}

		// Solo actualizar los archivos cuando cambiamos del panel de directorios al panel de archivos
		if previousPanel == 1 && s.ActivePanel == 2 {
			// Si venimos del panel de directorios, actualizar los archivos del directorio seleccionado
			if position >= 0 && position < len(items) {
				item := items[position]
				var selectedDir string
				if item == ".." {
					selectedDir = filepath.Dir(s.Directory)
				} else if item == "." {
					selectedDir = s.Directory
				} else {
					selectedDir = filepath.Join(s.Directory, item)
				}

				// Verificar si el directorio existe y es accesible
				if info, err := os.Stat(selectedDir); err == nil && info.IsDir() {
					// Actualizar la lista de archivos para el directorio seleccionado
					files, err := os.ReadDir(selectedDir)
					if err == nil {
						var fileList []string
						for _, file := range files {
							if !file.IsDir() { // Solo archivos
								fileList = append(fileList, file.Name())
							}
						}
						s.Files = fileList // Actualizamos los archivos
						s.FilePosition = 0 // Resetear la posición en el panel de archivos
					} else {
						s.Files = []string{} // Si hay error, limpiamos la lista de archivos
					}
				}
			}
		} else if s.ActivePanel == 2 && len(s.Files) > 0 {
			// Si ya estamos en el panel de archivos, solo resetear la posición
			s.FilePosition = 0
		}
	case "enter", "l":
		if s.ActivePanel == 1 && position >= 0 && position < len(items) {
			item := items[position]
			var newDir string
			if item == ".." {
				newDir = filepath.Dir(s.Directory)
			} else if item == "." {
				newDir = s.Directory
			} else {
				newDir = filepath.Join(s.Directory, item)
			}

			// Verificar si el directorio existe y es accesible
			if info, err := os.Stat(newDir); err == nil && info.IsDir() {
				// Guardar el estado actual en el historial antes de cambiar
				s.History = append(s.History, NavigationHistory{
					Directory: s.Directory,
					Position:  position,
				})

				s.Directory = newDir
				s.Filtered = PrepareDirItems(newDir)

				// Buscar la posición de "." en la nueva lista
				for i, item := range s.Filtered {
					if item == "." {
						position = i
						s.Position = i
						break
					}
				}

				items = s.Filtered // Actualizar los items con los nuevos
			}
		}
	case "esc", "h":
		// Navegar hacia atrás si no estamos en el directorio raíz de la aplicación
		rootDir := GetRootDirectory()
		if s.Directory != rootDir && len(s.History) > 0 {
			// Obtener el último estado del historial
			lastState := s.History[len(s.History)-1]

			// Verificar si el directorio del historial existe y es accesible
			if info, err := os.Stat(lastState.Directory); err == nil && info.IsDir() {
				s.Directory = lastState.Directory
				s.Filtered = PrepareDirItems(lastState.Directory)
				position = lastState.Position
				s.Position = lastState.Position
				items = s.Filtered

				// Eliminar el último estado del historial
				s.History = s.History[:len(s.History)-1]
			}
		}
	case "s":
		if s.ActivePanel == 1 {
			// Toggle de selección del directorio actual
			if position >= 0 && position < len(items) {
				item := items[position]
				if item != ".." {
					// Obtener el selector actual
					selector := GetCurrentSelector()

					// Determinar el estado actual de selección
					isSelected := selector.IsSelected(item)

					// Procesar el directorio actual
					dirPath := filepath.Join(s.Directory, item)
					processDirectoryRecursive(selector, dirPath, item, !isSelected)

					// Actualizar la lista de archivos si es necesario
					if !isSelected {
						// Si estamos seleccionando, actualizar la lista de archivos
						UpdateFileList(selector, s.Directory, item)
					} else {
						// Si estamos deseleccionando, limpiar la lista de archivos
						s.Files = []string{}
						s.FilePosition = 0
					}
				}
			}
		} else if s.ActivePanel == 2 && s.FilePosition >= 0 && s.FilePosition < len(s.Files) {
			// Obtener el nombre del archivo seleccionado
			selectedFile := s.Files[s.FilePosition]
			// Cambiar el estado de selección
			fileKey := s.GetFileSelectionKey(selectedFile)
			s.Selection[fileKey] = !s.Selection[fileKey]
		}
	case "a":
		if s.ActivePanel == 1 {
			// Verificar si todos los directorios están seleccionados (excluyendo '..' y '.')
			allSelected := true
			for _, item := range items {
				if item != ".." && item != "." && !s.IsSelected(item) {
					allSelected = false
					break
				}
			}

			// Si todos están seleccionados, deseleccionar todos (excluyendo '..' y '.')
			// Si no todos están seleccionados, seleccionar todos (excluyendo '..' y '.')
			for _, item := range items {
				if item != ".." && item != "." {
					// Procesar el directorio y sus subdirectorios si el modo include está activo
					dirPath := filepath.Join(s.Directory, item)
					processDirectoryRecursive(s, dirPath, item, !allSelected)
				}
			}
		} else if s.ActivePanel == 2 {
			// Verificar si todos los archivos están seleccionados
			allSelected := true
			for _, file := range s.Files {
				fileKey := s.GetFileSelectionKey(file)
				if !s.Selection[fileKey] {
					allSelected = false
					break
				}
			}

			// Si todos están seleccionados, deseleccionar todos
			// Si no todos están seleccionados, seleccionar todos
			for _, file := range s.Files {
				fileKey := s.GetFileSelectionKey(file)
				s.Selection[fileKey] = !allSelected
			}
		}
	}

	// Actualizar la posición en el selector
	s.Position = position

	// Actualizar los archivos cuando se navega
	s.UpdateFilesForCurrentDirectory()

	return position
}

// UpdateFileList actualiza la lista de archivos para un directorio
func UpdateFileList(selector *Selector, currentDir string, item string) {
	dirPath := filepath.Join(currentDir, item)
	files, err := os.ReadDir(dirPath)
	if err == nil {
		var fileList []string
		for _, file := range files {
			if !file.IsDir() { // Solo archivos
				fileList = append(fileList, file.Name())
			}
		}
		selector.Files = fileList
	}
}

// Función para obtener una lista de rutas seleccionadas
func getSelectedPaths(selection map[string]bool) []string {
	var paths []string
	pathsMap := make(map[string]bool) // Para evitar duplicados

	for path, selected := range selection {
		if selected {
			// Verificar si es un directorio o un archivo
			info, err := os.Stat(path)
			if err != nil {
				continue
			}

			// Añadir el camino sin duplicados
			if !pathsMap[path] {
				pathsMap[path] = true
				paths = append(paths, path)

				// Si es un directorio, no es necesario incluir sus archivos individuales
				// ya que serán procesados recursivamente por GenerateTextFile
				if info.IsDir() {
					// Marcar todos los archivos de este directorio como ya incluidos
					// para evitar procesarlos por separado
					prefix := path + string(os.PathSeparator)
					for otherPath := range selection {
						if strings.HasPrefix(otherPath, prefix) && selection[otherPath] {
							pathsMap[otherPath] = true // Marcar como ya incluido
						}
					}
				}
			}
		}
	}

	return paths
}

// Función para obtener las rutas excluidas
func getExcludedPaths(s *Selector) []string {
	// Esta implementación dependerá de cómo manejes las exclusiones en tu modelo
	// Por ahora, retorna una lista vacía
	return []string{}
}

// Contar archivos seleccionados
func countSelectedFiles(s *Selector) int {
	count := 0
	processedFiles := make(map[string]bool) // Para evitar duplicados

	// Procesar primero los directorios para marcar sus archivos como contados
	for path, selected := range s.Selection {
		if !selected {
			continue
		}

		info, err := os.Stat(path)
		if err != nil || !info.IsDir() {
			continue
		}

		if s.IncludeMode {
			// Contar archivos en el directorio si IncludeMode está activo
			filepath.Walk(path, func(p string, info os.FileInfo, err error) error {
				if err == nil && !info.IsDir() && !processedFiles[p] {
					processedFiles[p] = true
					count++
				}
				return nil
			})
		} else {
			// Contar solo archivos en el nivel superior del directorio
			files, err := os.ReadDir(path)
			if err == nil {
				for _, file := range files {
					filePath := filepath.Join(path, file.Name())
					fileInfo, err := file.Info()
					if err == nil && !fileInfo.IsDir() && !processedFiles[filePath] {
						processedFiles[filePath] = true
						count++
					}
				}
			}
		}
	}

	// Ahora procesar los archivos individuales que no estén dentro de directorios ya contados
	for path, selected := range s.Selection {
		if !selected {
			continue
		}

		info, err := os.Stat(path)
		if err != nil || info.IsDir() {
			continue
		}

		if !processedFiles[path] {
			processedFiles[path] = true
			count++
		}
	}

	return count
}

// Función para copiar al portapapeles
func copyToClipboard(text string) bool {
	var cmd *exec.Cmd

	switch runtime.GOOS {
	case "darwin": // macOS
		cmd = exec.Command("pbcopy")
	case "windows":
		// En Windows, necesitarías usar otro método, como el paquete clipboard
		// Por ahora, devolvemos falso como indicación de que no se soporta
		return false
	default: // Linux y otros
		// Primero intentar con xclip
		if _, err := exec.LookPath("xclip"); err == nil {
			cmd = exec.Command("xclip", "-selection", "clipboard")
		} else if _, err := exec.LookPath("xsel"); err == nil {
			// Luego intentar con xsel
			cmd = exec.Command("xsel", "--clipboard", "--input")
		} else if _, err := exec.LookPath("wl-copy"); err == nil {
			// Luego intentar con wl-copy (Wayland)
			cmd = exec.Command("wl-copy")
		} else {
			// No se encontró ninguna utilidad de portapapeles
			return false
		}
	}

	if cmd == nil {
		return false
	}

	// Crear un pipe para pasar el texto al comando
	pipe, err := cmd.StdinPipe()
	if err != nil {
		return false
	}

	// Iniciar el comando
	if err := cmd.Start(); err != nil {
		return false
	}

	// Escribir el texto en el pipe
	_, err = pipe.Write([]byte(text))
	if err != nil {
		return false
	}

	// Cerrar el pipe
	pipe.Close()

	// Esperar a que termine el comando
	return cmd.Wait() == nil
}

// Función recursiva para procesar directorios y archivos
func processDirectoryRecursive(selector *Selector, dirPath string, item string, selectState bool) {
	// Actualizar el estado de selección del directorio actual
	selectionKey := selector.GetSelectionKey(item)
	selector.Selection[selectionKey] = selectState

	// Si estamos deseleccionando, limpiar todos los archivos y subdirectorios
	// del directorio actual del mapa de selección
	if !selectState {
		// Borrar entradas de selección relacionadas con este directorio
		prefix := dirPath + string(os.PathSeparator)
		for path := range selector.Selection {
			if strings.HasPrefix(path, prefix) {
				selector.Selection[path] = false
			}
		}
		return
	}

	// Si estamos seleccionando y el modo include está activado,
	// procesar recursivamente los subdirectorios
	if selector.IncludeMode {
		// Leer el contenido del directorio
		entries, err := os.ReadDir(dirPath)
		if err == nil {
			for _, entry := range entries {
				if entry.IsDir() {
					// Procesar recursivamente el subdirectorio
					subDirPath := filepath.Join(dirPath, entry.Name())
					subItem := filepath.Join(item, entry.Name())
					processDirectory(selector, subDirPath, subItem, selectState)
				} else {
					// Seleccionar archivos en el directorio actual
					// No es necesario marcar los archivos como seleccionados individualmente
					// ya que el directorio padre ya está seleccionado y la función IsFileSelected
					// comprobará esto automáticamente.
				}
			}
		}
	}
}
